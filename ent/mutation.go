// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/0xfzz/tuwitt/ent/blockedusersrelationship"
	"github.com/0xfzz/tuwitt/ent/media"
	"github.com/0xfzz/tuwitt/ent/predicate"
	"github.com/0xfzz/tuwitt/ent/thread"
	"github.com/0xfzz/tuwitt/ent/threadcount"
	"github.com/0xfzz/tuwitt/ent/useraccount"
	"github.com/0xfzz/tuwitt/ent/usercount"
	"github.com/0xfzz/tuwitt/ent/userfollowerrelationship"
	"github.com/0xfzz/tuwitt/ent/userprofile"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockedUsersRelationship = "BlockedUsersRelationship"
	TypeMedia                    = "Media"
	TypeThread                   = "Thread"
	TypeThreadCount              = "ThreadCount"
	TypeThreadLikeUser           = "ThreadLikeUser"
	TypeUserAccount              = "UserAccount"
	TypeUserCount                = "UserCount"
	TypeUserFollowerRelationship = "UserFollowerRelationship"
	TypeUserProfile              = "UserProfile"
)

// BlockedUsersRelationshipMutation represents an operation that mutates the BlockedUsersRelationship nodes in the graph.
type BlockedUsersRelationshipMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	blocker             *int
	clearedblocker      bool
	blocked_user        *int
	clearedblocked_user bool
	done                bool
	oldValue            func(context.Context) (*BlockedUsersRelationship, error)
	predicates          []predicate.BlockedUsersRelationship
}

var _ ent.Mutation = (*BlockedUsersRelationshipMutation)(nil)

// blockedusersrelationshipOption allows management of the mutation configuration using functional options.
type blockedusersrelationshipOption func(*BlockedUsersRelationshipMutation)

// newBlockedUsersRelationshipMutation creates new mutation for the BlockedUsersRelationship entity.
func newBlockedUsersRelationshipMutation(c config, op Op, opts ...blockedusersrelationshipOption) *BlockedUsersRelationshipMutation {
	m := &BlockedUsersRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockedUsersRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockedUsersRelationshipID sets the ID field of the mutation.
func withBlockedUsersRelationshipID(id int) blockedusersrelationshipOption {
	return func(m *BlockedUsersRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockedUsersRelationship
		)
		m.oldValue = func(ctx context.Context) (*BlockedUsersRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockedUsersRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockedUsersRelationship sets the old BlockedUsersRelationship of the mutation.
func withBlockedUsersRelationship(node *BlockedUsersRelationship) blockedusersrelationshipOption {
	return func(m *BlockedUsersRelationshipMutation) {
		m.oldValue = func(context.Context) (*BlockedUsersRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockedUsersRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockedUsersRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockedUsersRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockedUsersRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockedUsersRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BlockedUsersRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlockedUsersRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlockedUsersRelationship entity.
// If the BlockedUsersRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockedUsersRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlockedUsersRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlockedUsersRelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlockedUsersRelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlockedUsersRelationship entity.
// If the BlockedUsersRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockedUsersRelationshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlockedUsersRelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *BlockedUsersRelationshipMutation) SetUserID(i int) {
	m.blocked_user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BlockedUsersRelationshipMutation) UserID() (r int, exists bool) {
	v := m.blocked_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BlockedUsersRelationship entity.
// If the BlockedUsersRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockedUsersRelationshipMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *BlockedUsersRelationshipMutation) ClearUserID() {
	m.blocked_user = nil
	m.clearedFields[blockedusersrelationship.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *BlockedUsersRelationshipMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[blockedusersrelationship.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BlockedUsersRelationshipMutation) ResetUserID() {
	m.blocked_user = nil
	delete(m.clearedFields, blockedusersrelationship.FieldUserID)
}

// SetBlockerID sets the "blocker_id" field.
func (m *BlockedUsersRelationshipMutation) SetBlockerID(i int) {
	m.blocker = &i
}

// BlockerID returns the value of the "blocker_id" field in the mutation.
func (m *BlockedUsersRelationshipMutation) BlockerID() (r int, exists bool) {
	v := m.blocker
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockerID returns the old "blocker_id" field's value of the BlockedUsersRelationship entity.
// If the BlockedUsersRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockedUsersRelationshipMutation) OldBlockerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockerID: %w", err)
	}
	return oldValue.BlockerID, nil
}

// ClearBlockerID clears the value of the "blocker_id" field.
func (m *BlockedUsersRelationshipMutation) ClearBlockerID() {
	m.blocker = nil
	m.clearedFields[blockedusersrelationship.FieldBlockerID] = struct{}{}
}

// BlockerIDCleared returns if the "blocker_id" field was cleared in this mutation.
func (m *BlockedUsersRelationshipMutation) BlockerIDCleared() bool {
	_, ok := m.clearedFields[blockedusersrelationship.FieldBlockerID]
	return ok
}

// ResetBlockerID resets all changes to the "blocker_id" field.
func (m *BlockedUsersRelationshipMutation) ResetBlockerID() {
	m.blocker = nil
	delete(m.clearedFields, blockedusersrelationship.FieldBlockerID)
}

// ClearBlocker clears the "blocker" edge to the UserAccount entity.
func (m *BlockedUsersRelationshipMutation) ClearBlocker() {
	m.clearedblocker = true
	m.clearedFields[blockedusersrelationship.FieldBlockerID] = struct{}{}
}

// BlockerCleared reports if the "blocker" edge to the UserAccount entity was cleared.
func (m *BlockedUsersRelationshipMutation) BlockerCleared() bool {
	return m.BlockerIDCleared() || m.clearedblocker
}

// BlockerIDs returns the "blocker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockerID instead. It exists only for internal usage by the builders.
func (m *BlockedUsersRelationshipMutation) BlockerIDs() (ids []int) {
	if id := m.blocker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlocker resets all changes to the "blocker" edge.
func (m *BlockedUsersRelationshipMutation) ResetBlocker() {
	m.blocker = nil
	m.clearedblocker = false
}

// SetBlockedUserID sets the "blocked_user" edge to the UserAccount entity by id.
func (m *BlockedUsersRelationshipMutation) SetBlockedUserID(id int) {
	m.blocked_user = &id
}

// ClearBlockedUser clears the "blocked_user" edge to the UserAccount entity.
func (m *BlockedUsersRelationshipMutation) ClearBlockedUser() {
	m.clearedblocked_user = true
	m.clearedFields[blockedusersrelationship.FieldUserID] = struct{}{}
}

// BlockedUserCleared reports if the "blocked_user" edge to the UserAccount entity was cleared.
func (m *BlockedUsersRelationshipMutation) BlockedUserCleared() bool {
	return m.UserIDCleared() || m.clearedblocked_user
}

// BlockedUserID returns the "blocked_user" edge ID in the mutation.
func (m *BlockedUsersRelationshipMutation) BlockedUserID() (id int, exists bool) {
	if m.blocked_user != nil {
		return *m.blocked_user, true
	}
	return
}

// BlockedUserIDs returns the "blocked_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockedUserID instead. It exists only for internal usage by the builders.
func (m *BlockedUsersRelationshipMutation) BlockedUserIDs() (ids []int) {
	if id := m.blocked_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlockedUser resets all changes to the "blocked_user" edge.
func (m *BlockedUsersRelationshipMutation) ResetBlockedUser() {
	m.blocked_user = nil
	m.clearedblocked_user = false
}

// Where appends a list predicates to the BlockedUsersRelationshipMutation builder.
func (m *BlockedUsersRelationshipMutation) Where(ps ...predicate.BlockedUsersRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockedUsersRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockedUsersRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockedUsersRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockedUsersRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockedUsersRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockedUsersRelationship).
func (m *BlockedUsersRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockedUsersRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, blockedusersrelationship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blockedusersrelationship.FieldUpdatedAt)
	}
	if m.blocked_user != nil {
		fields = append(fields, blockedusersrelationship.FieldUserID)
	}
	if m.blocker != nil {
		fields = append(fields, blockedusersrelationship.FieldBlockerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockedUsersRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockedusersrelationship.FieldCreatedAt:
		return m.CreatedAt()
	case blockedusersrelationship.FieldUpdatedAt:
		return m.UpdatedAt()
	case blockedusersrelationship.FieldUserID:
		return m.UserID()
	case blockedusersrelationship.FieldBlockerID:
		return m.BlockerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockedUsersRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockedusersrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blockedusersrelationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case blockedusersrelationship.FieldUserID:
		return m.OldUserID(ctx)
	case blockedusersrelationship.FieldBlockerID:
		return m.OldBlockerID(ctx)
	}
	return nil, fmt.Errorf("unknown BlockedUsersRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockedUsersRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockedusersrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blockedusersrelationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case blockedusersrelationship.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case blockedusersrelationship.FieldBlockerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockerID(v)
		return nil
	}
	return fmt.Errorf("unknown BlockedUsersRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockedUsersRelationshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockedUsersRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockedUsersRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlockedUsersRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockedUsersRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blockedusersrelationship.FieldUserID) {
		fields = append(fields, blockedusersrelationship.FieldUserID)
	}
	if m.FieldCleared(blockedusersrelationship.FieldBlockerID) {
		fields = append(fields, blockedusersrelationship.FieldBlockerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockedUsersRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockedUsersRelationshipMutation) ClearField(name string) error {
	switch name {
	case blockedusersrelationship.FieldUserID:
		m.ClearUserID()
		return nil
	case blockedusersrelationship.FieldBlockerID:
		m.ClearBlockerID()
		return nil
	}
	return fmt.Errorf("unknown BlockedUsersRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockedUsersRelationshipMutation) ResetField(name string) error {
	switch name {
	case blockedusersrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blockedusersrelationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case blockedusersrelationship.FieldUserID:
		m.ResetUserID()
		return nil
	case blockedusersrelationship.FieldBlockerID:
		m.ResetBlockerID()
		return nil
	}
	return fmt.Errorf("unknown BlockedUsersRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockedUsersRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blocker != nil {
		edges = append(edges, blockedusersrelationship.EdgeBlocker)
	}
	if m.blocked_user != nil {
		edges = append(edges, blockedusersrelationship.EdgeBlockedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockedUsersRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blockedusersrelationship.EdgeBlocker:
		if id := m.blocker; id != nil {
			return []ent.Value{*id}
		}
	case blockedusersrelationship.EdgeBlockedUser:
		if id := m.blocked_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockedUsersRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockedUsersRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockedUsersRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblocker {
		edges = append(edges, blockedusersrelationship.EdgeBlocker)
	}
	if m.clearedblocked_user {
		edges = append(edges, blockedusersrelationship.EdgeBlockedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockedUsersRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case blockedusersrelationship.EdgeBlocker:
		return m.clearedblocker
	case blockedusersrelationship.EdgeBlockedUser:
		return m.clearedblocked_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockedUsersRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case blockedusersrelationship.EdgeBlocker:
		m.ClearBlocker()
		return nil
	case blockedusersrelationship.EdgeBlockedUser:
		m.ClearBlockedUser()
		return nil
	}
	return fmt.Errorf("unknown BlockedUsersRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockedUsersRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case blockedusersrelationship.EdgeBlocker:
		m.ResetBlocker()
		return nil
	case blockedusersrelationship.EdgeBlockedUser:
		m.ResetBlockedUser()
		return nil
	}
	return fmt.Errorf("unknown BlockedUsersRelationship edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_path                        *string
	category                     *media.Category
	clearedFields                map[string]struct{}
	threads                      map[int]struct{}
	removedthreads               map[int]struct{}
	clearedthreads               bool
	owner_profile_picture        map[int]struct{}
	removedowner_profile_picture map[int]struct{}
	clearedowner_profile_picture bool
	owner_banner                 map[int]struct{}
	removedowner_banner          map[int]struct{}
	clearedowner_banner          bool
	done                         bool
	oldValue                     func(context.Context) (*Media, error)
	predicates                   []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id int) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *MediaMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MediaMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *MediaMutation) ResetPath() {
	m._path = nil
}

// SetCategory sets the "category" field.
func (m *MediaMutation) SetCategory(value media.Category) {
	m.category = &value
}

// Category returns the value of the "category" field in the mutation.
func (m *MediaMutation) Category() (r media.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCategory(ctx context.Context) (v media.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MediaMutation) ResetCategory() {
	m.category = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *MediaMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *MediaMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *MediaMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *MediaMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *MediaMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *MediaMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *MediaMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddOwnerProfilePictureIDs adds the "owner_profile_picture" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerProfilePictureIDs(ids ...int) {
	if m.owner_profile_picture == nil {
		m.owner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_profile_picture[ids[i]] = struct{}{}
	}
}

// ClearOwnerProfilePicture clears the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerProfilePicture() {
	m.clearedowner_profile_picture = true
}

// OwnerProfilePictureCleared reports if the "owner_profile_picture" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerProfilePictureCleared() bool {
	return m.clearedowner_profile_picture
}

// RemoveOwnerProfilePictureIDs removes the "owner_profile_picture" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerProfilePictureIDs(ids ...int) {
	if m.removedowner_profile_picture == nil {
		m.removedowner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_profile_picture, ids[i])
		m.removedowner_profile_picture[ids[i]] = struct{}{}
	}
}

// RemovedOwnerProfilePicture returns the removed IDs of the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerProfilePictureIDs() (ids []int) {
	for id := range m.removedowner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// OwnerProfilePictureIDs returns the "owner_profile_picture" edge IDs in the mutation.
func (m *MediaMutation) OwnerProfilePictureIDs() (ids []int) {
	for id := range m.owner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerProfilePicture resets all changes to the "owner_profile_picture" edge.
func (m *MediaMutation) ResetOwnerProfilePicture() {
	m.owner_profile_picture = nil
	m.clearedowner_profile_picture = false
	m.removedowner_profile_picture = nil
}

// AddOwnerBannerIDs adds the "owner_banner" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerBannerIDs(ids ...int) {
	if m.owner_banner == nil {
		m.owner_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_banner[ids[i]] = struct{}{}
	}
}

// ClearOwnerBanner clears the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerBanner() {
	m.clearedowner_banner = true
}

// OwnerBannerCleared reports if the "owner_banner" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerBannerCleared() bool {
	return m.clearedowner_banner
}

// RemoveOwnerBannerIDs removes the "owner_banner" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerBannerIDs(ids ...int) {
	if m.removedowner_banner == nil {
		m.removedowner_banner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_banner, ids[i])
		m.removedowner_banner[ids[i]] = struct{}{}
	}
}

// RemovedOwnerBanner returns the removed IDs of the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerBannerIDs() (ids []int) {
	for id := range m.removedowner_banner {
		ids = append(ids, id)
	}
	return
}

// OwnerBannerIDs returns the "owner_banner" edge IDs in the mutation.
func (m *MediaMutation) OwnerBannerIDs() (ids []int) {
	for id := range m.owner_banner {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerBanner resets all changes to the "owner_banner" edge.
func (m *MediaMutation) ResetOwnerBanner() {
	m.owner_banner = nil
	m.clearedowner_banner = false
	m.removedowner_banner = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._path != nil {
		fields = append(fields, media.FieldPath)
	}
	if m.category != nil {
		fields = append(fields, media.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldPath:
		return m.Path()
	case media.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldPath:
		return m.OldPath(ctx)
	case media.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case media.FieldCategory:
		v, ok := value.(media.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldPath:
		m.ResetPath()
		return nil
	case media.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.threads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.owner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.owner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.owner_profile_picture))
		for id := range m.owner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.owner_banner))
		for id := range m.owner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedthreads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.removedowner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.removedowner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.removedowner_profile_picture))
		for id := range m.removedowner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.removedowner_banner))
		for id := range m.removedowner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedthreads {
		edges = append(edges, media.EdgeThreads)
	}
	if m.clearedowner_profile_picture {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.clearedowner_banner {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeThreads:
		return m.clearedthreads
	case media.EdgeOwnerProfilePicture:
		return m.clearedowner_profile_picture
	case media.EdgeOwnerBanner:
		return m.clearedowner_banner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeThreads:
		m.ResetThreads()
		return nil
	case media.EdgeOwnerProfilePicture:
		m.ResetOwnerProfilePicture()
		return nil
	case media.EdgeOwnerBanner:
		m.ResetOwnerBanner()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	content             *string
	is_comment_disabled *bool
	visibility          *thread.Visibility
	status              *thread.Status
	is_deleted          *bool
	clearedFields       map[string]struct{}
	author              *int
	clearedauthor       bool
	parent              *int
	clearedparent       bool
	children            map[int]struct{}
	removedchildren     map[int]struct{}
	clearedchildren     bool
	thread_count        map[int]struct{}
	removedthread_count map[int]struct{}
	clearedthread_count bool
	reposted            *int
	clearedreposted     bool
	repost              *int
	clearedrepost       bool
	images              map[int]struct{}
	removedimages       map[int]struct{}
	clearedimages       bool
	done                bool
	oldValue            func(context.Context) (*Thread, error)
	predicates          []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ThreadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ThreadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ThreadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContent sets the "content" field.
func (m *ThreadMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ThreadMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ThreadMutation) ResetContent() {
	m.content = nil
}

// SetIsCommentDisabled sets the "is_comment_disabled" field.
func (m *ThreadMutation) SetIsCommentDisabled(b bool) {
	m.is_comment_disabled = &b
}

// IsCommentDisabled returns the value of the "is_comment_disabled" field in the mutation.
func (m *ThreadMutation) IsCommentDisabled() (r bool, exists bool) {
	v := m.is_comment_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCommentDisabled returns the old "is_comment_disabled" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsCommentDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCommentDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCommentDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCommentDisabled: %w", err)
	}
	return oldValue.IsCommentDisabled, nil
}

// ResetIsCommentDisabled resets all changes to the "is_comment_disabled" field.
func (m *ThreadMutation) ResetIsCommentDisabled() {
	m.is_comment_disabled = nil
}

// SetVisibility sets the "visibility" field.
func (m *ThreadMutation) SetVisibility(t thread.Visibility) {
	m.visibility = &t
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ThreadMutation) Visibility() (r thread.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldVisibility(ctx context.Context) (v thread.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ThreadMutation) ResetVisibility() {
	m.visibility = nil
}

// SetStatus sets the "status" field.
func (m *ThreadMutation) SetStatus(t thread.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadMutation) Status() (r thread.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldStatus(ctx context.Context) (v thread.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadMutation) ResetStatus() {
	m.status = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ThreadMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ThreadMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ThreadMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetAuthorID sets the "author_id" field.
func (m *ThreadMutation) SetAuthorID(i int) {
	m.author = &i
}

// AuthorID returns the value of the "author_id" field in the mutation.
func (m *ThreadMutation) AuthorID() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorID returns the old "author_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldAuthorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorID: %w", err)
	}
	return oldValue.AuthorID, nil
}

// ClearAuthorID clears the value of the "author_id" field.
func (m *ThreadMutation) ClearAuthorID() {
	m.author = nil
	m.clearedFields[thread.FieldAuthorID] = struct{}{}
}

// AuthorIDCleared returns if the "author_id" field was cleared in this mutation.
func (m *ThreadMutation) AuthorIDCleared() bool {
	_, ok := m.clearedFields[thread.FieldAuthorID]
	return ok
}

// ResetAuthorID resets all changes to the "author_id" field.
func (m *ThreadMutation) ResetAuthorID() {
	m.author = nil
	delete(m.clearedFields, thread.FieldAuthorID)
}

// SetParentID sets the "parent_id" field.
func (m *ThreadMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *ThreadMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *ThreadMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[thread.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *ThreadMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[thread.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *ThreadMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, thread.FieldParentID)
}

// SetRepostThreadID sets the "repost_thread_id" field.
func (m *ThreadMutation) SetRepostThreadID(i int) {
	m.reposted = &i
}

// RepostThreadID returns the value of the "repost_thread_id" field in the mutation.
func (m *ThreadMutation) RepostThreadID() (r int, exists bool) {
	v := m.reposted
	if v == nil {
		return
	}
	return *v, true
}

// OldRepostThreadID returns the old "repost_thread_id" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldRepostThreadID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepostThreadID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepostThreadID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepostThreadID: %w", err)
	}
	return oldValue.RepostThreadID, nil
}

// ClearRepostThreadID clears the value of the "repost_thread_id" field.
func (m *ThreadMutation) ClearRepostThreadID() {
	m.reposted = nil
	m.clearedFields[thread.FieldRepostThreadID] = struct{}{}
}

// RepostThreadIDCleared returns if the "repost_thread_id" field was cleared in this mutation.
func (m *ThreadMutation) RepostThreadIDCleared() bool {
	_, ok := m.clearedFields[thread.FieldRepostThreadID]
	return ok
}

// ResetRepostThreadID resets all changes to the "repost_thread_id" field.
func (m *ThreadMutation) ResetRepostThreadID() {
	m.reposted = nil
	delete(m.clearedFields, thread.FieldRepostThreadID)
}

// ClearAuthor clears the "author" edge to the UserAccount entity.
func (m *ThreadMutation) ClearAuthor() {
	m.clearedauthor = true
	m.clearedFields[thread.FieldAuthorID] = struct{}{}
}

// AuthorCleared reports if the "author" edge to the UserAccount entity was cleared.
func (m *ThreadMutation) AuthorCleared() bool {
	return m.AuthorIDCleared() || m.clearedauthor
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ThreadMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// ClearParent clears the "parent" edge to the Thread entity.
func (m *ThreadMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[thread.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Thread entity was cleared.
func (m *ThreadMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ThreadMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Thread entity by ids.
func (m *ThreadMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Thread entity.
func (m *ThreadMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Thread entity was cleared.
func (m *ThreadMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Thread entity by IDs.
func (m *ThreadMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Thread entity.
func (m *ThreadMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ThreadMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ThreadMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddThreadCountIDs adds the "thread_count" edge to the ThreadCount entity by ids.
func (m *ThreadMutation) AddThreadCountIDs(ids ...int) {
	if m.thread_count == nil {
		m.thread_count = make(map[int]struct{})
	}
	for i := range ids {
		m.thread_count[ids[i]] = struct{}{}
	}
}

// ClearThreadCount clears the "thread_count" edge to the ThreadCount entity.
func (m *ThreadMutation) ClearThreadCount() {
	m.clearedthread_count = true
}

// ThreadCountCleared reports if the "thread_count" edge to the ThreadCount entity was cleared.
func (m *ThreadMutation) ThreadCountCleared() bool {
	return m.clearedthread_count
}

// RemoveThreadCountIDs removes the "thread_count" edge to the ThreadCount entity by IDs.
func (m *ThreadMutation) RemoveThreadCountIDs(ids ...int) {
	if m.removedthread_count == nil {
		m.removedthread_count = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.thread_count, ids[i])
		m.removedthread_count[ids[i]] = struct{}{}
	}
}

// RemovedThreadCount returns the removed IDs of the "thread_count" edge to the ThreadCount entity.
func (m *ThreadMutation) RemovedThreadCountIDs() (ids []int) {
	for id := range m.removedthread_count {
		ids = append(ids, id)
	}
	return
}

// ThreadCountIDs returns the "thread_count" edge IDs in the mutation.
func (m *ThreadMutation) ThreadCountIDs() (ids []int) {
	for id := range m.thread_count {
		ids = append(ids, id)
	}
	return
}

// ResetThreadCount resets all changes to the "thread_count" edge.
func (m *ThreadMutation) ResetThreadCount() {
	m.thread_count = nil
	m.clearedthread_count = false
	m.removedthread_count = nil
}

// SetRepostedID sets the "reposted" edge to the Thread entity by id.
func (m *ThreadMutation) SetRepostedID(id int) {
	m.reposted = &id
}

// ClearReposted clears the "reposted" edge to the Thread entity.
func (m *ThreadMutation) ClearReposted() {
	m.clearedreposted = true
	m.clearedFields[thread.FieldRepostThreadID] = struct{}{}
}

// RepostedCleared reports if the "reposted" edge to the Thread entity was cleared.
func (m *ThreadMutation) RepostedCleared() bool {
	return m.RepostThreadIDCleared() || m.clearedreposted
}

// RepostedID returns the "reposted" edge ID in the mutation.
func (m *ThreadMutation) RepostedID() (id int, exists bool) {
	if m.reposted != nil {
		return *m.reposted, true
	}
	return
}

// RepostedIDs returns the "reposted" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepostedID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) RepostedIDs() (ids []int) {
	if id := m.reposted; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReposted resets all changes to the "reposted" edge.
func (m *ThreadMutation) ResetReposted() {
	m.reposted = nil
	m.clearedreposted = false
}

// SetRepostID sets the "repost" edge to the Thread entity by id.
func (m *ThreadMutation) SetRepostID(id int) {
	m.repost = &id
}

// ClearRepost clears the "repost" edge to the Thread entity.
func (m *ThreadMutation) ClearRepost() {
	m.clearedrepost = true
}

// RepostCleared reports if the "repost" edge to the Thread entity was cleared.
func (m *ThreadMutation) RepostCleared() bool {
	return m.clearedrepost
}

// RepostID returns the "repost" edge ID in the mutation.
func (m *ThreadMutation) RepostID() (id int, exists bool) {
	if m.repost != nil {
		return *m.repost, true
	}
	return
}

// RepostIDs returns the "repost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepostID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) RepostIDs() (ids []int) {
	if id := m.repost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepost resets all changes to the "repost" edge.
func (m *ThreadMutation) ResetRepost() {
	m.repost = nil
	m.clearedrepost = false
}

// AddImageIDs adds the "images" edge to the Media entity by ids.
func (m *ThreadMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Media entity.
func (m *ThreadMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Media entity was cleared.
func (m *ThreadMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Media entity by IDs.
func (m *ThreadMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Media entity.
func (m *ThreadMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ThreadMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ThreadMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, thread.FieldUpdatedAt)
	}
	if m.content != nil {
		fields = append(fields, thread.FieldContent)
	}
	if m.is_comment_disabled != nil {
		fields = append(fields, thread.FieldIsCommentDisabled)
	}
	if m.visibility != nil {
		fields = append(fields, thread.FieldVisibility)
	}
	if m.status != nil {
		fields = append(fields, thread.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, thread.FieldIsDeleted)
	}
	if m.author != nil {
		fields = append(fields, thread.FieldAuthorID)
	}
	if m.parent != nil {
		fields = append(fields, thread.FieldParentID)
	}
	if m.reposted != nil {
		fields = append(fields, thread.FieldRepostThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	case thread.FieldUpdatedAt:
		return m.UpdatedAt()
	case thread.FieldContent:
		return m.Content()
	case thread.FieldIsCommentDisabled:
		return m.IsCommentDisabled()
	case thread.FieldVisibility:
		return m.Visibility()
	case thread.FieldStatus:
		return m.Status()
	case thread.FieldIsDeleted:
		return m.IsDeleted()
	case thread.FieldAuthorID:
		return m.AuthorID()
	case thread.FieldParentID:
		return m.ParentID()
	case thread.FieldRepostThreadID:
		return m.RepostThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case thread.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case thread.FieldContent:
		return m.OldContent(ctx)
	case thread.FieldIsCommentDisabled:
		return m.OldIsCommentDisabled(ctx)
	case thread.FieldVisibility:
		return m.OldVisibility(ctx)
	case thread.FieldStatus:
		return m.OldStatus(ctx)
	case thread.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case thread.FieldAuthorID:
		return m.OldAuthorID(ctx)
	case thread.FieldParentID:
		return m.OldParentID(ctx)
	case thread.FieldRepostThreadID:
		return m.OldRepostThreadID(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case thread.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case thread.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case thread.FieldIsCommentDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCommentDisabled(v)
		return nil
	case thread.FieldVisibility:
		v, ok := value.(thread.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case thread.FieldStatus:
		v, ok := value.(thread.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case thread.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case thread.FieldAuthorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorID(v)
		return nil
	case thread.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case thread.FieldRepostThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepostThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thread.FieldAuthorID) {
		fields = append(fields, thread.FieldAuthorID)
	}
	if m.FieldCleared(thread.FieldParentID) {
		fields = append(fields, thread.FieldParentID)
	}
	if m.FieldCleared(thread.FieldRepostThreadID) {
		fields = append(fields, thread.FieldRepostThreadID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	switch name {
	case thread.FieldAuthorID:
		m.ClearAuthorID()
		return nil
	case thread.FieldParentID:
		m.ClearParentID()
		return nil
	case thread.FieldRepostThreadID:
		m.ClearRepostThreadID()
		return nil
	}
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case thread.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case thread.FieldContent:
		m.ResetContent()
		return nil
	case thread.FieldIsCommentDisabled:
		m.ResetIsCommentDisabled()
		return nil
	case thread.FieldVisibility:
		m.ResetVisibility()
		return nil
	case thread.FieldStatus:
		m.ResetStatus()
		return nil
	case thread.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case thread.FieldAuthorID:
		m.ResetAuthorID()
		return nil
	case thread.FieldParentID:
		m.ResetParentID()
		return nil
	case thread.FieldRepostThreadID:
		m.ResetRepostThreadID()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.author != nil {
		edges = append(edges, thread.EdgeAuthor)
	}
	if m.parent != nil {
		edges = append(edges, thread.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, thread.EdgeChildren)
	}
	if m.thread_count != nil {
		edges = append(edges, thread.EdgeThreadCount)
	}
	if m.reposted != nil {
		edges = append(edges, thread.EdgeReposted)
	}
	if m.repost != nil {
		edges = append(edges, thread.EdgeRepost)
	}
	if m.images != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeThreadCount:
		ids := make([]ent.Value, 0, len(m.thread_count))
		for id := range m.thread_count {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeReposted:
		if id := m.reposted; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeRepost:
		if id := m.repost; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, thread.EdgeChildren)
	}
	if m.removedthread_count != nil {
		edges = append(edges, thread.EdgeThreadCount)
	}
	if m.removedimages != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeThreadCount:
		ids := make([]ent.Value, 0, len(m.removedthread_count))
		for id := range m.removedthread_count {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedauthor {
		edges = append(edges, thread.EdgeAuthor)
	}
	if m.clearedparent {
		edges = append(edges, thread.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, thread.EdgeChildren)
	}
	if m.clearedthread_count {
		edges = append(edges, thread.EdgeThreadCount)
	}
	if m.clearedreposted {
		edges = append(edges, thread.EdgeReposted)
	}
	if m.clearedrepost {
		edges = append(edges, thread.EdgeRepost)
	}
	if m.clearedimages {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeAuthor:
		return m.clearedauthor
	case thread.EdgeParent:
		return m.clearedparent
	case thread.EdgeChildren:
		return m.clearedchildren
	case thread.EdgeThreadCount:
		return m.clearedthread_count
	case thread.EdgeReposted:
		return m.clearedreposted
	case thread.EdgeRepost:
		return m.clearedrepost
	case thread.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case thread.EdgeParent:
		m.ClearParent()
		return nil
	case thread.EdgeReposted:
		m.ClearReposted()
		return nil
	case thread.EdgeRepost:
		m.ClearRepost()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case thread.EdgeParent:
		m.ResetParent()
		return nil
	case thread.EdgeChildren:
		m.ResetChildren()
		return nil
	case thread.EdgeThreadCount:
		m.ResetThreadCount()
		return nil
	case thread.EdgeReposted:
		m.ResetReposted()
		return nil
	case thread.EdgeRepost:
		m.ResetRepost()
		return nil
	case thread.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadCountMutation represents an operation that mutates the ThreadCount nodes in the graph.
type ThreadCountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	reply_count    *int
	addreply_count *int
	like_count     *int
	addlike_count  *int
	clearedFields  map[string]struct{}
	thread         *int
	clearedthread  bool
	done           bool
	oldValue       func(context.Context) (*ThreadCount, error)
	predicates     []predicate.ThreadCount
}

var _ ent.Mutation = (*ThreadCountMutation)(nil)

// threadcountOption allows management of the mutation configuration using functional options.
type threadcountOption func(*ThreadCountMutation)

// newThreadCountMutation creates new mutation for the ThreadCount entity.
func newThreadCountMutation(c config, op Op, opts ...threadcountOption) *ThreadCountMutation {
	m := &ThreadCountMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadCountID sets the ID field of the mutation.
func withThreadCountID(id int) threadcountOption {
	return func(m *ThreadCountMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadCount
		)
		m.oldValue = func(ctx context.Context) (*ThreadCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadCount sets the old ThreadCount of the mutation.
func withThreadCount(node *ThreadCount) threadcountOption {
	return func(m *ThreadCountMutation) {
		m.oldValue = func(context.Context) (*ThreadCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReplyCount sets the "reply_count" field.
func (m *ThreadCountMutation) SetReplyCount(i int) {
	m.reply_count = &i
	m.addreply_count = nil
}

// ReplyCount returns the value of the "reply_count" field in the mutation.
func (m *ThreadCountMutation) ReplyCount() (r int, exists bool) {
	v := m.reply_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyCount returns the old "reply_count" field's value of the ThreadCount entity.
// If the ThreadCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCountMutation) OldReplyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyCount: %w", err)
	}
	return oldValue.ReplyCount, nil
}

// AddReplyCount adds i to the "reply_count" field.
func (m *ThreadCountMutation) AddReplyCount(i int) {
	if m.addreply_count != nil {
		*m.addreply_count += i
	} else {
		m.addreply_count = &i
	}
}

// AddedReplyCount returns the value that was added to the "reply_count" field in this mutation.
func (m *ThreadCountMutation) AddedReplyCount() (r int, exists bool) {
	v := m.addreply_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplyCount resets all changes to the "reply_count" field.
func (m *ThreadCountMutation) ResetReplyCount() {
	m.reply_count = nil
	m.addreply_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *ThreadCountMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *ThreadCountMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the ThreadCount entity.
// If the ThreadCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCountMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *ThreadCountMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *ThreadCountMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *ThreadCountMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetThreadID sets the "thread" edge to the Thread entity by id.
func (m *ThreadCountMutation) SetThreadID(id int) {
	m.thread = &id
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadCountMutation) ClearThread() {
	m.clearedthread = true
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadCountMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadID returns the "thread" edge ID in the mutation.
func (m *ThreadCountMutation) ThreadID() (id int, exists bool) {
	if m.thread != nil {
		return *m.thread, true
	}
	return
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadCountMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadCountMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the ThreadCountMutation builder.
func (m *ThreadCountMutation) Where(ps ...predicate.ThreadCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadCount).
func (m *ThreadCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.reply_count != nil {
		fields = append(fields, threadcount.FieldReplyCount)
	}
	if m.like_count != nil {
		fields = append(fields, threadcount.FieldLikeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.ReplyCount()
	case threadcount.FieldLikeCount:
		return m.LikeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.OldReplyCount(ctx)
	case threadcount.FieldLikeCount:
		return m.OldLikeCount(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadcount.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyCount(v)
		return nil
	case threadcount.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadCountMutation) AddedFields() []string {
	var fields []string
	if m.addreply_count != nil {
		fields = append(fields, threadcount.FieldReplyCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, threadcount.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.AddedReplyCount()
	case threadcount.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threadcount.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyCount(v)
		return nil
	case threadcount.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadCountMutation) ResetField(name string) error {
	switch name {
	case threadcount.FieldReplyCount:
		m.ResetReplyCount()
		return nil
	case threadcount.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	}
	return fmt.Errorf("unknown ThreadCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.thread != nil {
		edges = append(edges, threadcount.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadcount.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedthread {
		edges = append(edges, threadcount.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadCountMutation) EdgeCleared(name string) bool {
	switch name {
	case threadcount.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadCountMutation) ClearEdge(name string) error {
	switch name {
	case threadcount.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadCountMutation) ResetEdge(name string) error {
	switch name {
	case threadcount.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadCount edge %s", name)
}

// ThreadLikeUserMutation represents an operation that mutates the ThreadLikeUser nodes in the graph.
type ThreadLikeUserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ThreadLikeUser, error)
	predicates    []predicate.ThreadLikeUser
}

var _ ent.Mutation = (*ThreadLikeUserMutation)(nil)

// threadlikeuserOption allows management of the mutation configuration using functional options.
type threadlikeuserOption func(*ThreadLikeUserMutation)

// newThreadLikeUserMutation creates new mutation for the ThreadLikeUser entity.
func newThreadLikeUserMutation(c config, op Op, opts ...threadlikeuserOption) *ThreadLikeUserMutation {
	m := &ThreadLikeUserMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadLikeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadLikeUserID sets the ID field of the mutation.
func withThreadLikeUserID(id int) threadlikeuserOption {
	return func(m *ThreadLikeUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadLikeUser
		)
		m.oldValue = func(ctx context.Context) (*ThreadLikeUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadLikeUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadLikeUser sets the old ThreadLikeUser of the mutation.
func withThreadLikeUser(node *ThreadLikeUser) threadlikeuserOption {
	return func(m *ThreadLikeUserMutation) {
		m.oldValue = func(context.Context) (*ThreadLikeUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadLikeUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadLikeUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadLikeUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadLikeUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadLikeUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ThreadLikeUserMutation builder.
func (m *ThreadLikeUserMutation) Where(ps ...predicate.ThreadLikeUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadLikeUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadLikeUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadLikeUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadLikeUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadLikeUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadLikeUser).
func (m *ThreadLikeUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadLikeUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadLikeUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadLikeUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ThreadLikeUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadLikeUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadLikeUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadLikeUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadLikeUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadLikeUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ThreadLikeUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadLikeUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadLikeUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadLikeUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadLikeUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadLikeUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ThreadLikeUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadLikeUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadLikeUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadLikeUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadLikeUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadLikeUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadLikeUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadLikeUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ThreadLikeUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadLikeUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ThreadLikeUser edge %s", name)
}

// UserAccountMutation represents an operation that mutates the UserAccount nodes in the graph.
type UserAccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	email                *string
	username             *string
	password             *[]byte
	is_verified          *bool
	is_private           *bool
	is_email_verified    *bool
	clearedFields        map[string]struct{}
	profile              *int
	clearedprofile       bool
	followers            map[int]struct{}
	removedfollowers     map[int]struct{}
	clearedfollowers     bool
	followings           map[int]struct{}
	removedfollowings    map[int]struct{}
	clearedfollowings    bool
	blocked_by           map[int]struct{}
	removedblocked_by    map[int]struct{}
	clearedblocked_by    bool
	blocked_users        map[int]struct{}
	removedblocked_users map[int]struct{}
	clearedblocked_users bool
	user_count           *int
	cleareduser_count    bool
	threads              map[int]struct{}
	removedthreads       map[int]struct{}
	clearedthreads       bool
	done                 bool
	oldValue             func(context.Context) (*UserAccount, error)
	predicates           []predicate.UserAccount
}

var _ ent.Mutation = (*UserAccountMutation)(nil)

// useraccountOption allows management of the mutation configuration using functional options.
type useraccountOption func(*UserAccountMutation)

// newUserAccountMutation creates new mutation for the UserAccount entity.
func newUserAccountMutation(c config, op Op, opts ...useraccountOption) *UserAccountMutation {
	m := &UserAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAccountID sets the ID field of the mutation.
func withUserAccountID(id int) useraccountOption {
	return func(m *UserAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAccount
		)
		m.oldValue = func(ctx context.Context) (*UserAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAccount sets the old UserAccount of the mutation.
func withUserAccount(node *UserAccount) useraccountOption {
	return func(m *UserAccountMutation) {
		m.oldValue = func(context.Context) (*UserAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserAccountMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserAccountMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserAccountMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *UserAccountMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserAccountMutation) ResetPassword() {
	m.password = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserAccountMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserAccountMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserAccountMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetIsPrivate sets the "is_private" field.
func (m *UserAccountMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *UserAccountMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *UserAccountMutation) ResetIsPrivate() {
	m.is_private = nil
}

// SetIsEmailVerified sets the "is_email_verified" field.
func (m *UserAccountMutation) SetIsEmailVerified(b bool) {
	m.is_email_verified = &b
}

// IsEmailVerified returns the value of the "is_email_verified" field in the mutation.
func (m *UserAccountMutation) IsEmailVerified() (r bool, exists bool) {
	v := m.is_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEmailVerified returns the old "is_email_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEmailVerified: %w", err)
	}
	return oldValue.IsEmailVerified, nil
}

// ResetIsEmailVerified resets all changes to the "is_email_verified" field.
func (m *UserAccountMutation) ResetIsEmailVerified() {
	m.is_email_verified = nil
}

// SetProfileID sets the "profile" edge to the UserProfile entity by id.
func (m *UserAccountMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the UserProfile entity.
func (m *UserAccountMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the UserProfile entity was cleared.
func (m *UserAccountMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserAccountMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserAccountMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserAccountMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddFollowerIDs adds the "followers" edge to the UserFollowerRelationship entity by ids.
func (m *UserAccountMutation) AddFollowerIDs(ids ...int) {
	if m.followers == nil {
		m.followers = make(map[int]struct{})
	}
	for i := range ids {
		m.followers[ids[i]] = struct{}{}
	}
}

// ClearFollowers clears the "followers" edge to the UserFollowerRelationship entity.
func (m *UserAccountMutation) ClearFollowers() {
	m.clearedfollowers = true
}

// FollowersCleared reports if the "followers" edge to the UserFollowerRelationship entity was cleared.
func (m *UserAccountMutation) FollowersCleared() bool {
	return m.clearedfollowers
}

// RemoveFollowerIDs removes the "followers" edge to the UserFollowerRelationship entity by IDs.
func (m *UserAccountMutation) RemoveFollowerIDs(ids ...int) {
	if m.removedfollowers == nil {
		m.removedfollowers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followers, ids[i])
		m.removedfollowers[ids[i]] = struct{}{}
	}
}

// RemovedFollowers returns the removed IDs of the "followers" edge to the UserFollowerRelationship entity.
func (m *UserAccountMutation) RemovedFollowersIDs() (ids []int) {
	for id := range m.removedfollowers {
		ids = append(ids, id)
	}
	return
}

// FollowersIDs returns the "followers" edge IDs in the mutation.
func (m *UserAccountMutation) FollowersIDs() (ids []int) {
	for id := range m.followers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowers resets all changes to the "followers" edge.
func (m *UserAccountMutation) ResetFollowers() {
	m.followers = nil
	m.clearedfollowers = false
	m.removedfollowers = nil
}

// AddFollowingIDs adds the "followings" edge to the UserFollowerRelationship entity by ids.
func (m *UserAccountMutation) AddFollowingIDs(ids ...int) {
	if m.followings == nil {
		m.followings = make(map[int]struct{})
	}
	for i := range ids {
		m.followings[ids[i]] = struct{}{}
	}
}

// ClearFollowings clears the "followings" edge to the UserFollowerRelationship entity.
func (m *UserAccountMutation) ClearFollowings() {
	m.clearedfollowings = true
}

// FollowingsCleared reports if the "followings" edge to the UserFollowerRelationship entity was cleared.
func (m *UserAccountMutation) FollowingsCleared() bool {
	return m.clearedfollowings
}

// RemoveFollowingIDs removes the "followings" edge to the UserFollowerRelationship entity by IDs.
func (m *UserAccountMutation) RemoveFollowingIDs(ids ...int) {
	if m.removedfollowings == nil {
		m.removedfollowings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followings, ids[i])
		m.removedfollowings[ids[i]] = struct{}{}
	}
}

// RemovedFollowings returns the removed IDs of the "followings" edge to the UserFollowerRelationship entity.
func (m *UserAccountMutation) RemovedFollowingsIDs() (ids []int) {
	for id := range m.removedfollowings {
		ids = append(ids, id)
	}
	return
}

// FollowingsIDs returns the "followings" edge IDs in the mutation.
func (m *UserAccountMutation) FollowingsIDs() (ids []int) {
	for id := range m.followings {
		ids = append(ids, id)
	}
	return
}

// ResetFollowings resets all changes to the "followings" edge.
func (m *UserAccountMutation) ResetFollowings() {
	m.followings = nil
	m.clearedfollowings = false
	m.removedfollowings = nil
}

// AddBlockedByIDs adds the "blocked_by" edge to the BlockedUsersRelationship entity by ids.
func (m *UserAccountMutation) AddBlockedByIDs(ids ...int) {
	if m.blocked_by == nil {
		m.blocked_by = make(map[int]struct{})
	}
	for i := range ids {
		m.blocked_by[ids[i]] = struct{}{}
	}
}

// ClearBlockedBy clears the "blocked_by" edge to the BlockedUsersRelationship entity.
func (m *UserAccountMutation) ClearBlockedBy() {
	m.clearedblocked_by = true
}

// BlockedByCleared reports if the "blocked_by" edge to the BlockedUsersRelationship entity was cleared.
func (m *UserAccountMutation) BlockedByCleared() bool {
	return m.clearedblocked_by
}

// RemoveBlockedByIDs removes the "blocked_by" edge to the BlockedUsersRelationship entity by IDs.
func (m *UserAccountMutation) RemoveBlockedByIDs(ids ...int) {
	if m.removedblocked_by == nil {
		m.removedblocked_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocked_by, ids[i])
		m.removedblocked_by[ids[i]] = struct{}{}
	}
}

// RemovedBlockedBy returns the removed IDs of the "blocked_by" edge to the BlockedUsersRelationship entity.
func (m *UserAccountMutation) RemovedBlockedByIDs() (ids []int) {
	for id := range m.removedblocked_by {
		ids = append(ids, id)
	}
	return
}

// BlockedByIDs returns the "blocked_by" edge IDs in the mutation.
func (m *UserAccountMutation) BlockedByIDs() (ids []int) {
	for id := range m.blocked_by {
		ids = append(ids, id)
	}
	return
}

// ResetBlockedBy resets all changes to the "blocked_by" edge.
func (m *UserAccountMutation) ResetBlockedBy() {
	m.blocked_by = nil
	m.clearedblocked_by = false
	m.removedblocked_by = nil
}

// AddBlockedUserIDs adds the "blocked_users" edge to the BlockedUsersRelationship entity by ids.
func (m *UserAccountMutation) AddBlockedUserIDs(ids ...int) {
	if m.blocked_users == nil {
		m.blocked_users = make(map[int]struct{})
	}
	for i := range ids {
		m.blocked_users[ids[i]] = struct{}{}
	}
}

// ClearBlockedUsers clears the "blocked_users" edge to the BlockedUsersRelationship entity.
func (m *UserAccountMutation) ClearBlockedUsers() {
	m.clearedblocked_users = true
}

// BlockedUsersCleared reports if the "blocked_users" edge to the BlockedUsersRelationship entity was cleared.
func (m *UserAccountMutation) BlockedUsersCleared() bool {
	return m.clearedblocked_users
}

// RemoveBlockedUserIDs removes the "blocked_users" edge to the BlockedUsersRelationship entity by IDs.
func (m *UserAccountMutation) RemoveBlockedUserIDs(ids ...int) {
	if m.removedblocked_users == nil {
		m.removedblocked_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocked_users, ids[i])
		m.removedblocked_users[ids[i]] = struct{}{}
	}
}

// RemovedBlockedUsers returns the removed IDs of the "blocked_users" edge to the BlockedUsersRelationship entity.
func (m *UserAccountMutation) RemovedBlockedUsersIDs() (ids []int) {
	for id := range m.removedblocked_users {
		ids = append(ids, id)
	}
	return
}

// BlockedUsersIDs returns the "blocked_users" edge IDs in the mutation.
func (m *UserAccountMutation) BlockedUsersIDs() (ids []int) {
	for id := range m.blocked_users {
		ids = append(ids, id)
	}
	return
}

// ResetBlockedUsers resets all changes to the "blocked_users" edge.
func (m *UserAccountMutation) ResetBlockedUsers() {
	m.blocked_users = nil
	m.clearedblocked_users = false
	m.removedblocked_users = nil
}

// SetUserCountID sets the "user_count" edge to the UserCount entity by id.
func (m *UserAccountMutation) SetUserCountID(id int) {
	m.user_count = &id
}

// ClearUserCount clears the "user_count" edge to the UserCount entity.
func (m *UserAccountMutation) ClearUserCount() {
	m.cleareduser_count = true
}

// UserCountCleared reports if the "user_count" edge to the UserCount entity was cleared.
func (m *UserAccountMutation) UserCountCleared() bool {
	return m.cleareduser_count
}

// UserCountID returns the "user_count" edge ID in the mutation.
func (m *UserAccountMutation) UserCountID() (id int, exists bool) {
	if m.user_count != nil {
		return *m.user_count, true
	}
	return
}

// UserCountIDs returns the "user_count" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserCountID instead. It exists only for internal usage by the builders.
func (m *UserAccountMutation) UserCountIDs() (ids []int) {
	if id := m.user_count; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserCount resets all changes to the "user_count" edge.
func (m *UserAccountMutation) ResetUserCount() {
	m.user_count = nil
	m.cleareduser_count = false
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *UserAccountMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *UserAccountMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *UserAccountMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *UserAccountMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *UserAccountMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *UserAccountMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *UserAccountMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// Where appends a list predicates to the UserAccountMutation builder.
func (m *UserAccountMutation) Where(ps ...predicate.UserAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAccount).
func (m *UserAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, useraccount.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, useraccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, useraccount.FieldPassword)
	}
	if m.is_verified != nil {
		fields = append(fields, useraccount.FieldIsVerified)
	}
	if m.is_private != nil {
		fields = append(fields, useraccount.FieldIsPrivate)
	}
	if m.is_email_verified != nil {
		fields = append(fields, useraccount.FieldIsEmailVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraccount.FieldEmail:
		return m.Email()
	case useraccount.FieldUsername:
		return m.Username()
	case useraccount.FieldPassword:
		return m.Password()
	case useraccount.FieldIsVerified:
		return m.IsVerified()
	case useraccount.FieldIsPrivate:
		return m.IsPrivate()
	case useraccount.FieldIsEmailVerified:
		return m.IsEmailVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraccount.FieldEmail:
		return m.OldEmail(ctx)
	case useraccount.FieldUsername:
		return m.OldUsername(ctx)
	case useraccount.FieldPassword:
		return m.OldPassword(ctx)
	case useraccount.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case useraccount.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case useraccount.FieldIsEmailVerified:
		return m.OldIsEmailVerified(ctx)
	}
	return nil, fmt.Errorf("unknown UserAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case useraccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case useraccount.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case useraccount.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case useraccount.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case useraccount.FieldIsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEmailVerified(v)
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAccountMutation) ResetField(name string) error {
	switch name {
	case useraccount.FieldEmail:
		m.ResetEmail()
		return nil
	case useraccount.FieldUsername:
		m.ResetUsername()
		return nil
	case useraccount.FieldPassword:
		m.ResetPassword()
		return nil
	case useraccount.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case useraccount.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case useraccount.FieldIsEmailVerified:
		m.ResetIsEmailVerified()
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.profile != nil {
		edges = append(edges, useraccount.EdgeProfile)
	}
	if m.followers != nil {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.followings != nil {
		edges = append(edges, useraccount.EdgeFollowings)
	}
	if m.blocked_by != nil {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.blocked_users != nil {
		edges = append(edges, useraccount.EdgeBlockedUsers)
	}
	if m.user_count != nil {
		edges = append(edges, useraccount.EdgeUserCount)
	}
	if m.threads != nil {
		edges = append(edges, useraccount.EdgeThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraccount.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case useraccount.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.followers))
		for id := range m.followers {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeFollowings:
		ids := make([]ent.Value, 0, len(m.followings))
		for id := range m.followings {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.blocked_by))
		for id := range m.blocked_by {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedUsers:
		ids := make([]ent.Value, 0, len(m.blocked_users))
		for id := range m.blocked_users {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeUserCount:
		if id := m.user_count; id != nil {
			return []ent.Value{*id}
		}
	case useraccount.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedfollowers != nil {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.removedfollowings != nil {
		edges = append(edges, useraccount.EdgeFollowings)
	}
	if m.removedblocked_by != nil {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.removedblocked_users != nil {
		edges = append(edges, useraccount.EdgeBlockedUsers)
	}
	if m.removedthreads != nil {
		edges = append(edges, useraccount.EdgeThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case useraccount.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.removedfollowers))
		for id := range m.removedfollowers {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeFollowings:
		ids := make([]ent.Value, 0, len(m.removedfollowings))
		for id := range m.removedfollowings {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.removedblocked_by))
		for id := range m.removedblocked_by {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedUsers:
		ids := make([]ent.Value, 0, len(m.removedblocked_users))
		for id := range m.removedblocked_users {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedprofile {
		edges = append(edges, useraccount.EdgeProfile)
	}
	if m.clearedfollowers {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.clearedfollowings {
		edges = append(edges, useraccount.EdgeFollowings)
	}
	if m.clearedblocked_by {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.clearedblocked_users {
		edges = append(edges, useraccount.EdgeBlockedUsers)
	}
	if m.cleareduser_count {
		edges = append(edges, useraccount.EdgeUserCount)
	}
	if m.clearedthreads {
		edges = append(edges, useraccount.EdgeThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case useraccount.EdgeProfile:
		return m.clearedprofile
	case useraccount.EdgeFollowers:
		return m.clearedfollowers
	case useraccount.EdgeFollowings:
		return m.clearedfollowings
	case useraccount.EdgeBlockedBy:
		return m.clearedblocked_by
	case useraccount.EdgeBlockedUsers:
		return m.clearedblocked_users
	case useraccount.EdgeUserCount:
		return m.cleareduser_count
	case useraccount.EdgeThreads:
		return m.clearedthreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAccountMutation) ClearEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ClearProfile()
		return nil
	case useraccount.EdgeUserCount:
		m.ClearUserCount()
		return nil
	}
	return fmt.Errorf("unknown UserAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAccountMutation) ResetEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ResetProfile()
		return nil
	case useraccount.EdgeFollowers:
		m.ResetFollowers()
		return nil
	case useraccount.EdgeFollowings:
		m.ResetFollowings()
		return nil
	case useraccount.EdgeBlockedBy:
		m.ResetBlockedBy()
		return nil
	case useraccount.EdgeBlockedUsers:
		m.ResetBlockedUsers()
		return nil
	case useraccount.EdgeUserCount:
		m.ResetUserCount()
		return nil
	case useraccount.EdgeThreads:
		m.ResetThreads()
		return nil
	}
	return fmt.Errorf("unknown UserAccount edge %s", name)
}

// UserCountMutation represents an operation that mutates the UserCount nodes in the graph.
type UserCountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	follower_count      *int
	addfollower_count   *int
	followings_count    *int
	addfollowings_count *int
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*UserCount, error)
	predicates          []predicate.UserCount
}

var _ ent.Mutation = (*UserCountMutation)(nil)

// usercountOption allows management of the mutation configuration using functional options.
type usercountOption func(*UserCountMutation)

// newUserCountMutation creates new mutation for the UserCount entity.
func newUserCountMutation(c config, op Op, opts ...usercountOption) *UserCountMutation {
	m := &UserCountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCountID sets the ID field of the mutation.
func withUserCountID(id int) usercountOption {
	return func(m *UserCountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCount
		)
		m.oldValue = func(ctx context.Context) (*UserCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCount sets the old UserCount of the mutation.
func withUserCount(node *UserCount) usercountOption {
	return func(m *UserCountMutation) {
		m.oldValue = func(context.Context) (*UserCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFollowerCount sets the "follower_count" field.
func (m *UserCountMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *UserCountMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the UserCount entity.
// If the UserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCountMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *UserCountMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *UserCountMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *UserCountMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetFollowingsCount sets the "followings_count" field.
func (m *UserCountMutation) SetFollowingsCount(i int) {
	m.followings_count = &i
	m.addfollowings_count = nil
}

// FollowingsCount returns the value of the "followings_count" field in the mutation.
func (m *UserCountMutation) FollowingsCount() (r int, exists bool) {
	v := m.followings_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingsCount returns the old "followings_count" field's value of the UserCount entity.
// If the UserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCountMutation) OldFollowingsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingsCount: %w", err)
	}
	return oldValue.FollowingsCount, nil
}

// AddFollowingsCount adds i to the "followings_count" field.
func (m *UserCountMutation) AddFollowingsCount(i int) {
	if m.addfollowings_count != nil {
		*m.addfollowings_count += i
	} else {
		m.addfollowings_count = &i
	}
}

// AddedFollowingsCount returns the value that was added to the "followings_count" field in this mutation.
func (m *UserCountMutation) AddedFollowingsCount() (r int, exists bool) {
	v := m.addfollowings_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingsCount resets all changes to the "followings_count" field.
func (m *UserCountMutation) ResetFollowingsCount() {
	m.followings_count = nil
	m.addfollowings_count = nil
}

// SetUserID sets the "user" edge to the UserAccount entity by id.
func (m *UserCountMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the UserAccount entity.
func (m *UserCountMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserAccount entity was cleared.
func (m *UserCountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserCountMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserCountMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserCountMutation builder.
func (m *UserCountMutation) Where(ps ...predicate.UserCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCount).
func (m *UserCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.follower_count != nil {
		fields = append(fields, usercount.FieldFollowerCount)
	}
	if m.followings_count != nil {
		fields = append(fields, usercount.FieldFollowingsCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.FollowerCount()
	case usercount.FieldFollowingsCount:
		return m.FollowingsCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case usercount.FieldFollowingsCount:
		return m.OldFollowingsCount(ctx)
	}
	return nil, fmt.Errorf("unknown UserCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercount.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case usercount.FieldFollowingsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingsCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCountMutation) AddedFields() []string {
	var fields []string
	if m.addfollower_count != nil {
		fields = append(fields, usercount.FieldFollowerCount)
	}
	if m.addfollowings_count != nil {
		fields = append(fields, usercount.FieldFollowingsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.AddedFollowerCount()
	case usercount.FieldFollowingsCount:
		return m.AddedFollowingsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercount.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case usercount.FieldFollowingsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingsCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCountMutation) ResetField(name string) error {
	switch name {
	case usercount.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case usercount.FieldFollowingsCount:
		m.ResetFollowingsCount()
		return nil
	}
	return fmt.Errorf("unknown UserCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usercount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercount.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usercount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCountMutation) EdgeCleared(name string) bool {
	switch name {
	case usercount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCountMutation) ClearEdge(name string) error {
	switch name {
	case usercount.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCountMutation) ResetEdge(name string) error {
	switch name {
	case usercount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserCount edge %s", name)
}

// UserFollowerRelationshipMutation represents an operation that mutates the UserFollowerRelationship nodes in the graph.
type UserFollowerRelationshipMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	follower         *int
	clearedfollower  bool
	following        *int
	clearedfollowing bool
	done             bool
	oldValue         func(context.Context) (*UserFollowerRelationship, error)
	predicates       []predicate.UserFollowerRelationship
}

var _ ent.Mutation = (*UserFollowerRelationshipMutation)(nil)

// userfollowerrelationshipOption allows management of the mutation configuration using functional options.
type userfollowerrelationshipOption func(*UserFollowerRelationshipMutation)

// newUserFollowerRelationshipMutation creates new mutation for the UserFollowerRelationship entity.
func newUserFollowerRelationshipMutation(c config, op Op, opts ...userfollowerrelationshipOption) *UserFollowerRelationshipMutation {
	m := &UserFollowerRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFollowerRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFollowerRelationshipID sets the ID field of the mutation.
func withUserFollowerRelationshipID(id int) userfollowerrelationshipOption {
	return func(m *UserFollowerRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFollowerRelationship
		)
		m.oldValue = func(ctx context.Context) (*UserFollowerRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFollowerRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFollowerRelationship sets the old UserFollowerRelationship of the mutation.
func withUserFollowerRelationship(node *UserFollowerRelationship) userfollowerrelationshipOption {
	return func(m *UserFollowerRelationshipMutation) {
		m.oldValue = func(context.Context) (*UserFollowerRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFollowerRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFollowerRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFollowerRelationshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFollowerRelationshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFollowerRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFollowerRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFollowerRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFollowerRelationship entity.
// If the UserFollowerRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowerRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFollowerRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserFollowerRelationshipMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserFollowerRelationshipMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserFollowerRelationship entity.
// If the UserFollowerRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowerRelationshipMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserFollowerRelationshipMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserFollowerRelationshipMutation) SetUserID(i int) {
	m.following = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFollowerRelationshipMutation) UserID() (r int, exists bool) {
	v := m.following
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFollowerRelationship entity.
// If the UserFollowerRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowerRelationshipMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserFollowerRelationshipMutation) ClearUserID() {
	m.following = nil
	m.clearedFields[userfollowerrelationship.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserFollowerRelationshipMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userfollowerrelationship.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFollowerRelationshipMutation) ResetUserID() {
	m.following = nil
	delete(m.clearedFields, userfollowerrelationship.FieldUserID)
}

// SetFollowerID sets the "follower_id" field.
func (m *UserFollowerRelationshipMutation) SetFollowerID(i int) {
	m.follower = &i
}

// FollowerID returns the value of the "follower_id" field in the mutation.
func (m *UserFollowerRelationshipMutation) FollowerID() (r int, exists bool) {
	v := m.follower
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerID returns the old "follower_id" field's value of the UserFollowerRelationship entity.
// If the UserFollowerRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFollowerRelationshipMutation) OldFollowerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerID: %w", err)
	}
	return oldValue.FollowerID, nil
}

// ClearFollowerID clears the value of the "follower_id" field.
func (m *UserFollowerRelationshipMutation) ClearFollowerID() {
	m.follower = nil
	m.clearedFields[userfollowerrelationship.FieldFollowerID] = struct{}{}
}

// FollowerIDCleared returns if the "follower_id" field was cleared in this mutation.
func (m *UserFollowerRelationshipMutation) FollowerIDCleared() bool {
	_, ok := m.clearedFields[userfollowerrelationship.FieldFollowerID]
	return ok
}

// ResetFollowerID resets all changes to the "follower_id" field.
func (m *UserFollowerRelationshipMutation) ResetFollowerID() {
	m.follower = nil
	delete(m.clearedFields, userfollowerrelationship.FieldFollowerID)
}

// ClearFollower clears the "follower" edge to the UserAccount entity.
func (m *UserFollowerRelationshipMutation) ClearFollower() {
	m.clearedfollower = true
	m.clearedFields[userfollowerrelationship.FieldFollowerID] = struct{}{}
}

// FollowerCleared reports if the "follower" edge to the UserAccount entity was cleared.
func (m *UserFollowerRelationshipMutation) FollowerCleared() bool {
	return m.FollowerIDCleared() || m.clearedfollower
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowerID instead. It exists only for internal usage by the builders.
func (m *UserFollowerRelationshipMutation) FollowerIDs() (ids []int) {
	if id := m.follower; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *UserFollowerRelationshipMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
}

// SetFollowingID sets the "following" edge to the UserAccount entity by id.
func (m *UserFollowerRelationshipMutation) SetFollowingID(id int) {
	m.following = &id
}

// ClearFollowing clears the "following" edge to the UserAccount entity.
func (m *UserFollowerRelationshipMutation) ClearFollowing() {
	m.clearedfollowing = true
	m.clearedFields[userfollowerrelationship.FieldUserID] = struct{}{}
}

// FollowingCleared reports if the "following" edge to the UserAccount entity was cleared.
func (m *UserFollowerRelationshipMutation) FollowingCleared() bool {
	return m.UserIDCleared() || m.clearedfollowing
}

// FollowingID returns the "following" edge ID in the mutation.
func (m *UserFollowerRelationshipMutation) FollowingID() (id int, exists bool) {
	if m.following != nil {
		return *m.following, true
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FollowingID instead. It exists only for internal usage by the builders.
func (m *UserFollowerRelationshipMutation) FollowingIDs() (ids []int) {
	if id := m.following; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *UserFollowerRelationshipMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
}

// Where appends a list predicates to the UserFollowerRelationshipMutation builder.
func (m *UserFollowerRelationshipMutation) Where(ps ...predicate.UserFollowerRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFollowerRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFollowerRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFollowerRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFollowerRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFollowerRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFollowerRelationship).
func (m *UserFollowerRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFollowerRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, userfollowerrelationship.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userfollowerrelationship.FieldUpdatedAt)
	}
	if m.following != nil {
		fields = append(fields, userfollowerrelationship.FieldUserID)
	}
	if m.follower != nil {
		fields = append(fields, userfollowerrelationship.FieldFollowerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFollowerRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfollowerrelationship.FieldCreatedAt:
		return m.CreatedAt()
	case userfollowerrelationship.FieldUpdatedAt:
		return m.UpdatedAt()
	case userfollowerrelationship.FieldUserID:
		return m.UserID()
	case userfollowerrelationship.FieldFollowerID:
		return m.FollowerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFollowerRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfollowerrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfollowerrelationship.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userfollowerrelationship.FieldUserID:
		return m.OldUserID(ctx)
	case userfollowerrelationship.FieldFollowerID:
		return m.OldFollowerID(ctx)
	}
	return nil, fmt.Errorf("unknown UserFollowerRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowerRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfollowerrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfollowerrelationship.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userfollowerrelationship.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfollowerrelationship.FieldFollowerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFollowerRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFollowerRelationshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFollowerRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFollowerRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFollowerRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFollowerRelationshipMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userfollowerrelationship.FieldUserID) {
		fields = append(fields, userfollowerrelationship.FieldUserID)
	}
	if m.FieldCleared(userfollowerrelationship.FieldFollowerID) {
		fields = append(fields, userfollowerrelationship.FieldFollowerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFollowerRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFollowerRelationshipMutation) ClearField(name string) error {
	switch name {
	case userfollowerrelationship.FieldUserID:
		m.ClearUserID()
		return nil
	case userfollowerrelationship.FieldFollowerID:
		m.ClearFollowerID()
		return nil
	}
	return fmt.Errorf("unknown UserFollowerRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFollowerRelationshipMutation) ResetField(name string) error {
	switch name {
	case userfollowerrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfollowerrelationship.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userfollowerrelationship.FieldUserID:
		m.ResetUserID()
		return nil
	case userfollowerrelationship.FieldFollowerID:
		m.ResetFollowerID()
		return nil
	}
	return fmt.Errorf("unknown UserFollowerRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFollowerRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, userfollowerrelationship.EdgeFollower)
	}
	if m.following != nil {
		edges = append(edges, userfollowerrelationship.EdgeFollowing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFollowerRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfollowerrelationship.EdgeFollower:
		if id := m.follower; id != nil {
			return []ent.Value{*id}
		}
	case userfollowerrelationship.EdgeFollowing:
		if id := m.following; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFollowerRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFollowerRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFollowerRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, userfollowerrelationship.EdgeFollower)
	}
	if m.clearedfollowing {
		edges = append(edges, userfollowerrelationship.EdgeFollowing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFollowerRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case userfollowerrelationship.EdgeFollower:
		return m.clearedfollower
	case userfollowerrelationship.EdgeFollowing:
		return m.clearedfollowing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFollowerRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case userfollowerrelationship.EdgeFollower:
		m.ClearFollower()
		return nil
	case userfollowerrelationship.EdgeFollowing:
		m.ClearFollowing()
		return nil
	}
	return fmt.Errorf("unknown UserFollowerRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFollowerRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case userfollowerrelationship.EdgeFollower:
		m.ResetFollower()
		return nil
	case userfollowerrelationship.EdgeFollowing:
		m.ResetFollowing()
		return nil
	}
	return fmt.Errorf("unknown UserFollowerRelationship edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	display_name           *string
	bio                    *string
	clearedFields          map[string]struct{}
	account                *int
	clearedaccount         bool
	profile_picture        *int
	clearedprofile_picture bool
	banner                 *int
	clearedbanner          bool
	done                   bool
	oldValue               func(context.Context) (*UserProfile, error)
	predicates             []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id int) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplayName sets the "display_name" field.
func (m *UserProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserProfileMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetBio sets the "bio" field.
func (m *UserProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[userprofile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, userprofile.FieldBio)
}

// SetProfilePictureID sets the "profile_picture_id" field.
func (m *UserProfileMutation) SetProfilePictureID(i int) {
	m.profile_picture = &i
}

// ProfilePictureID returns the value of the "profile_picture_id" field in the mutation.
func (m *UserProfileMutation) ProfilePictureID() (r int, exists bool) {
	v := m.profile_picture
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureID returns the old "profile_picture_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldProfilePictureID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureID: %w", err)
	}
	return oldValue.ProfilePictureID, nil
}

// ClearProfilePictureID clears the value of the "profile_picture_id" field.
func (m *UserProfileMutation) ClearProfilePictureID() {
	m.profile_picture = nil
	m.clearedFields[userprofile.FieldProfilePictureID] = struct{}{}
}

// ProfilePictureIDCleared returns if the "profile_picture_id" field was cleared in this mutation.
func (m *UserProfileMutation) ProfilePictureIDCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldProfilePictureID]
	return ok
}

// ResetProfilePictureID resets all changes to the "profile_picture_id" field.
func (m *UserProfileMutation) ResetProfilePictureID() {
	m.profile_picture = nil
	delete(m.clearedFields, userprofile.FieldProfilePictureID)
}

// SetBannerID sets the "banner_id" field.
func (m *UserProfileMutation) SetBannerID(i int) {
	m.banner = &i
}

// BannerID returns the value of the "banner_id" field in the mutation.
func (m *UserProfileMutation) BannerID() (r int, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerID returns the old "banner_id" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBannerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBannerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBannerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerID: %w", err)
	}
	return oldValue.BannerID, nil
}

// ClearBannerID clears the value of the "banner_id" field.
func (m *UserProfileMutation) ClearBannerID() {
	m.banner = nil
	m.clearedFields[userprofile.FieldBannerID] = struct{}{}
}

// BannerIDCleared returns if the "banner_id" field was cleared in this mutation.
func (m *UserProfileMutation) BannerIDCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBannerID]
	return ok
}

// ResetBannerID resets all changes to the "banner_id" field.
func (m *UserProfileMutation) ResetBannerID() {
	m.banner = nil
	delete(m.clearedFields, userprofile.FieldBannerID)
}

// SetAccountID sets the "account" edge to the UserAccount entity by id.
func (m *UserProfileMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the UserAccount entity.
func (m *UserProfileMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the UserAccount entity was cleared.
func (m *UserProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *UserProfileMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearProfilePicture clears the "profile_picture" edge to the Media entity.
func (m *UserProfileMutation) ClearProfilePicture() {
	m.clearedprofile_picture = true
	m.clearedFields[userprofile.FieldProfilePictureID] = struct{}{}
}

// ProfilePictureCleared reports if the "profile_picture" edge to the Media entity was cleared.
func (m *UserProfileMutation) ProfilePictureCleared() bool {
	return m.ProfilePictureIDCleared() || m.clearedprofile_picture
}

// ProfilePictureIDs returns the "profile_picture" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfilePictureID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) ProfilePictureIDs() (ids []int) {
	if id := m.profile_picture; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfilePicture resets all changes to the "profile_picture" edge.
func (m *UserProfileMutation) ResetProfilePicture() {
	m.profile_picture = nil
	m.clearedprofile_picture = false
}

// ClearBanner clears the "banner" edge to the Media entity.
func (m *UserProfileMutation) ClearBanner() {
	m.clearedbanner = true
	m.clearedFields[userprofile.FieldBannerID] = struct{}{}
}

// BannerCleared reports if the "banner" edge to the Media entity was cleared.
func (m *UserProfileMutation) BannerCleared() bool {
	return m.BannerIDCleared() || m.clearedbanner
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) BannerIDs() (ids []int) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *UserProfileMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.display_name != nil {
		fields = append(fields, userprofile.FieldDisplayName)
	}
	if m.bio != nil {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.profile_picture != nil {
		fields = append(fields, userprofile.FieldProfilePictureID)
	}
	if m.banner != nil {
		fields = append(fields, userprofile.FieldBannerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.DisplayName()
	case userprofile.FieldBio:
		return m.Bio()
	case userprofile.FieldProfilePictureID:
		return m.ProfilePictureID()
	case userprofile.FieldBannerID:
		return m.BannerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case userprofile.FieldBio:
		return m.OldBio(ctx)
	case userprofile.FieldProfilePictureID:
		return m.OldProfilePictureID(ctx)
	case userprofile.FieldBannerID:
		return m.OldBannerID(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case userprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case userprofile.FieldProfilePictureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureID(v)
		return nil
	case userprofile.FieldBannerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerID(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprofile.FieldBio) {
		fields = append(fields, userprofile.FieldBio)
	}
	if m.FieldCleared(userprofile.FieldProfilePictureID) {
		fields = append(fields, userprofile.FieldProfilePictureID)
	}
	if m.FieldCleared(userprofile.FieldBannerID) {
		fields = append(fields, userprofile.FieldBannerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	switch name {
	case userprofile.FieldBio:
		m.ClearBio()
		return nil
	case userprofile.FieldProfilePictureID:
		m.ClearProfilePictureID()
		return nil
	case userprofile.FieldBannerID:
		m.ClearBannerID()
		return nil
	}
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case userprofile.FieldBio:
		m.ResetBio()
		return nil
	case userprofile.FieldProfilePictureID:
		m.ResetProfilePictureID()
		return nil
	case userprofile.FieldBannerID:
		m.ResetBannerID()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.account != nil {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.profile_picture != nil {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.banner != nil {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeProfilePicture:
		if id := m.profile_picture; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccount {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.clearedprofile_picture {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.clearedbanner {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeAccount:
		return m.clearedaccount
	case userprofile.EdgeProfilePicture:
		return m.clearedprofile_picture
	case userprofile.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ClearAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ClearProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ResetAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ResetProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
