// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/0xfzz/tuwitt/ent/media"
	"github.com/0xfzz/tuwitt/ent/predicate"
	"github.com/0xfzz/tuwitt/ent/thread"
	"github.com/0xfzz/tuwitt/ent/threadcount"
	"github.com/0xfzz/tuwitt/ent/useraccount"
	"github.com/0xfzz/tuwitt/ent/usercount"
	"github.com/0xfzz/tuwitt/ent/userprofile"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMedia       = "Media"
	TypeThread      = "Thread"
	TypeThreadCount = "ThreadCount"
	TypeUserAccount = "UserAccount"
	TypeUserCount   = "UserCount"
	TypeUserProfile = "UserProfile"
)

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_path                        *string
	category                     *media.Category
	clearedFields                map[string]struct{}
	threads                      map[int]struct{}
	removedthreads               map[int]struct{}
	clearedthreads               bool
	owner_profile_picture        map[int]struct{}
	removedowner_profile_picture map[int]struct{}
	clearedowner_profile_picture bool
	owner_banner                 map[int]struct{}
	removedowner_banner          map[int]struct{}
	clearedowner_banner          bool
	done                         bool
	oldValue                     func(context.Context) (*Media, error)
	predicates                   []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id int) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *MediaMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MediaMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *MediaMutation) ResetPath() {
	m._path = nil
}

// SetCategory sets the "category" field.
func (m *MediaMutation) SetCategory(value media.Category) {
	m.category = &value
}

// Category returns the value of the "category" field in the mutation.
func (m *MediaMutation) Category() (r media.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCategory(ctx context.Context) (v media.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MediaMutation) ResetCategory() {
	m.category = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *MediaMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *MediaMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *MediaMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *MediaMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *MediaMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *MediaMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *MediaMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddOwnerProfilePictureIDs adds the "owner_profile_picture" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerProfilePictureIDs(ids ...int) {
	if m.owner_profile_picture == nil {
		m.owner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_profile_picture[ids[i]] = struct{}{}
	}
}

// ClearOwnerProfilePicture clears the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerProfilePicture() {
	m.clearedowner_profile_picture = true
}

// OwnerProfilePictureCleared reports if the "owner_profile_picture" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerProfilePictureCleared() bool {
	return m.clearedowner_profile_picture
}

// RemoveOwnerProfilePictureIDs removes the "owner_profile_picture" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerProfilePictureIDs(ids ...int) {
	if m.removedowner_profile_picture == nil {
		m.removedowner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_profile_picture, ids[i])
		m.removedowner_profile_picture[ids[i]] = struct{}{}
	}
}

// RemovedOwnerProfilePicture returns the removed IDs of the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerProfilePictureIDs() (ids []int) {
	for id := range m.removedowner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// OwnerProfilePictureIDs returns the "owner_profile_picture" edge IDs in the mutation.
func (m *MediaMutation) OwnerProfilePictureIDs() (ids []int) {
	for id := range m.owner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerProfilePicture resets all changes to the "owner_profile_picture" edge.
func (m *MediaMutation) ResetOwnerProfilePicture() {
	m.owner_profile_picture = nil
	m.clearedowner_profile_picture = false
	m.removedowner_profile_picture = nil
}

// AddOwnerBannerIDs adds the "owner_banner" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerBannerIDs(ids ...int) {
	if m.owner_banner == nil {
		m.owner_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_banner[ids[i]] = struct{}{}
	}
}

// ClearOwnerBanner clears the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerBanner() {
	m.clearedowner_banner = true
}

// OwnerBannerCleared reports if the "owner_banner" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerBannerCleared() bool {
	return m.clearedowner_banner
}

// RemoveOwnerBannerIDs removes the "owner_banner" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerBannerIDs(ids ...int) {
	if m.removedowner_banner == nil {
		m.removedowner_banner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_banner, ids[i])
		m.removedowner_banner[ids[i]] = struct{}{}
	}
}

// RemovedOwnerBanner returns the removed IDs of the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerBannerIDs() (ids []int) {
	for id := range m.removedowner_banner {
		ids = append(ids, id)
	}
	return
}

// OwnerBannerIDs returns the "owner_banner" edge IDs in the mutation.
func (m *MediaMutation) OwnerBannerIDs() (ids []int) {
	for id := range m.owner_banner {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerBanner resets all changes to the "owner_banner" edge.
func (m *MediaMutation) ResetOwnerBanner() {
	m.owner_banner = nil
	m.clearedowner_banner = false
	m.removedowner_banner = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._path != nil {
		fields = append(fields, media.FieldPath)
	}
	if m.category != nil {
		fields = append(fields, media.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldPath:
		return m.Path()
	case media.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldPath:
		return m.OldPath(ctx)
	case media.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case media.FieldCategory:
		v, ok := value.(media.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldPath:
		m.ResetPath()
		return nil
	case media.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.threads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.owner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.owner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.owner_profile_picture))
		for id := range m.owner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.owner_banner))
		for id := range m.owner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedthreads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.removedowner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.removedowner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.removedowner_profile_picture))
		for id := range m.removedowner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.removedowner_banner))
		for id := range m.removedowner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedthreads {
		edges = append(edges, media.EdgeThreads)
	}
	if m.clearedowner_profile_picture {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.clearedowner_banner {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeThreads:
		return m.clearedthreads
	case media.EdgeOwnerProfilePicture:
		return m.clearedowner_profile_picture
	case media.EdgeOwnerBanner:
		return m.clearedowner_banner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeThreads:
		m.ResetThreads()
		return nil
	case media.EdgeOwnerProfilePicture:
		m.ResetOwnerProfilePicture()
		return nil
	case media.EdgeOwnerBanner:
		m.ResetOwnerBanner()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	content              *string
	is_comment_disabled  *bool
	visibility           *thread.Visibility
	status               *thread.Status
	is_deleted           *bool
	clearedFields        map[string]struct{}
	parent_thread        *int
	clearedparent_thread bool
	child_threads        map[int]struct{}
	removedchild_threads map[int]struct{}
	clearedchild_threads bool
	images               map[int]struct{}
	removedimages        map[int]struct{}
	clearedimages        bool
	done                 bool
	oldValue             func(context.Context) (*Thread, error)
	predicates           []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *ThreadMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ThreadMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ThreadMutation) ResetContent() {
	m.content = nil
}

// SetIsCommentDisabled sets the "is_comment_disabled" field.
func (m *ThreadMutation) SetIsCommentDisabled(b bool) {
	m.is_comment_disabled = &b
}

// IsCommentDisabled returns the value of the "is_comment_disabled" field in the mutation.
func (m *ThreadMutation) IsCommentDisabled() (r bool, exists bool) {
	v := m.is_comment_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCommentDisabled returns the old "is_comment_disabled" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsCommentDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCommentDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCommentDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCommentDisabled: %w", err)
	}
	return oldValue.IsCommentDisabled, nil
}

// ResetIsCommentDisabled resets all changes to the "is_comment_disabled" field.
func (m *ThreadMutation) ResetIsCommentDisabled() {
	m.is_comment_disabled = nil
}

// SetVisibility sets the "visibility" field.
func (m *ThreadMutation) SetVisibility(t thread.Visibility) {
	m.visibility = &t
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ThreadMutation) Visibility() (r thread.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldVisibility(ctx context.Context) (v thread.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ThreadMutation) ResetVisibility() {
	m.visibility = nil
}

// SetStatus sets the "status" field.
func (m *ThreadMutation) SetStatus(t thread.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadMutation) Status() (r thread.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldStatus(ctx context.Context) (v thread.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadMutation) ResetStatus() {
	m.status = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ThreadMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ThreadMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ThreadMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetParentThreadID sets the "parent_thread" edge to the Thread entity by id.
func (m *ThreadMutation) SetParentThreadID(id int) {
	m.parent_thread = &id
}

// ClearParentThread clears the "parent_thread" edge to the Thread entity.
func (m *ThreadMutation) ClearParentThread() {
	m.clearedparent_thread = true
}

// ParentThreadCleared reports if the "parent_thread" edge to the Thread entity was cleared.
func (m *ThreadMutation) ParentThreadCleared() bool {
	return m.clearedparent_thread
}

// ParentThreadID returns the "parent_thread" edge ID in the mutation.
func (m *ThreadMutation) ParentThreadID() (id int, exists bool) {
	if m.parent_thread != nil {
		return *m.parent_thread, true
	}
	return
}

// ParentThreadIDs returns the "parent_thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ParentThreadIDs() (ids []int) {
	if id := m.parent_thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentThread resets all changes to the "parent_thread" edge.
func (m *ThreadMutation) ResetParentThread() {
	m.parent_thread = nil
	m.clearedparent_thread = false
}

// AddChildThreadIDs adds the "child_threads" edge to the Thread entity by ids.
func (m *ThreadMutation) AddChildThreadIDs(ids ...int) {
	if m.child_threads == nil {
		m.child_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.child_threads[ids[i]] = struct{}{}
	}
}

// ClearChildThreads clears the "child_threads" edge to the Thread entity.
func (m *ThreadMutation) ClearChildThreads() {
	m.clearedchild_threads = true
}

// ChildThreadsCleared reports if the "child_threads" edge to the Thread entity was cleared.
func (m *ThreadMutation) ChildThreadsCleared() bool {
	return m.clearedchild_threads
}

// RemoveChildThreadIDs removes the "child_threads" edge to the Thread entity by IDs.
func (m *ThreadMutation) RemoveChildThreadIDs(ids ...int) {
	if m.removedchild_threads == nil {
		m.removedchild_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_threads, ids[i])
		m.removedchild_threads[ids[i]] = struct{}{}
	}
}

// RemovedChildThreads returns the removed IDs of the "child_threads" edge to the Thread entity.
func (m *ThreadMutation) RemovedChildThreadsIDs() (ids []int) {
	for id := range m.removedchild_threads {
		ids = append(ids, id)
	}
	return
}

// ChildThreadsIDs returns the "child_threads" edge IDs in the mutation.
func (m *ThreadMutation) ChildThreadsIDs() (ids []int) {
	for id := range m.child_threads {
		ids = append(ids, id)
	}
	return
}

// ResetChildThreads resets all changes to the "child_threads" edge.
func (m *ThreadMutation) ResetChildThreads() {
	m.child_threads = nil
	m.clearedchild_threads = false
	m.removedchild_threads = nil
}

// AddImageIDs adds the "images" edge to the Media entity by ids.
func (m *ThreadMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Media entity.
func (m *ThreadMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Media entity was cleared.
func (m *ThreadMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Media entity by IDs.
func (m *ThreadMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Media entity.
func (m *ThreadMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ThreadMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ThreadMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.content != nil {
		fields = append(fields, thread.FieldContent)
	}
	if m.is_comment_disabled != nil {
		fields = append(fields, thread.FieldIsCommentDisabled)
	}
	if m.visibility != nil {
		fields = append(fields, thread.FieldVisibility)
	}
	if m.status != nil {
		fields = append(fields, thread.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, thread.FieldIsDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldContent:
		return m.Content()
	case thread.FieldIsCommentDisabled:
		return m.IsCommentDisabled()
	case thread.FieldVisibility:
		return m.Visibility()
	case thread.FieldStatus:
		return m.Status()
	case thread.FieldIsDeleted:
		return m.IsDeleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldContent:
		return m.OldContent(ctx)
	case thread.FieldIsCommentDisabled:
		return m.OldIsCommentDisabled(ctx)
	case thread.FieldVisibility:
		return m.OldVisibility(ctx)
	case thread.FieldStatus:
		return m.OldStatus(ctx)
	case thread.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case thread.FieldIsCommentDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCommentDisabled(v)
		return nil
	case thread.FieldVisibility:
		v, ok := value.(thread.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case thread.FieldStatus:
		v, ok := value.(thread.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case thread.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldContent:
		m.ResetContent()
		return nil
	case thread.FieldIsCommentDisabled:
		m.ResetIsCommentDisabled()
		return nil
	case thread.FieldVisibility:
		m.ResetVisibility()
		return nil
	case thread.FieldStatus:
		m.ResetStatus()
		return nil
	case thread.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent_thread != nil {
		edges = append(edges, thread.EdgeParentThread)
	}
	if m.child_threads != nil {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.images != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeParentThread:
		if id := m.parent_thread; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeChildThreads:
		ids := make([]ent.Value, 0, len(m.child_threads))
		for id := range m.child_threads {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchild_threads != nil {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.removedimages != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeChildThreads:
		ids := make([]ent.Value, 0, len(m.removedchild_threads))
		for id := range m.removedchild_threads {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent_thread {
		edges = append(edges, thread.EdgeParentThread)
	}
	if m.clearedchild_threads {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.clearedimages {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeParentThread:
		return m.clearedparent_thread
	case thread.EdgeChildThreads:
		return m.clearedchild_threads
	case thread.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeParentThread:
		m.ClearParentThread()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeParentThread:
		m.ResetParentThread()
		return nil
	case thread.EdgeChildThreads:
		m.ResetChildThreads()
		return nil
	case thread.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadCountMutation represents an operation that mutates the ThreadCount nodes in the graph.
type ThreadCountMutation struct {
	config
	op             Op
	typ            string
	id             *int
	reply_count    *int
	addreply_count *int
	like_count     *int
	addlike_count  *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ThreadCount, error)
	predicates     []predicate.ThreadCount
}

var _ ent.Mutation = (*ThreadCountMutation)(nil)

// threadcountOption allows management of the mutation configuration using functional options.
type threadcountOption func(*ThreadCountMutation)

// newThreadCountMutation creates new mutation for the ThreadCount entity.
func newThreadCountMutation(c config, op Op, opts ...threadcountOption) *ThreadCountMutation {
	m := &ThreadCountMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadCountID sets the ID field of the mutation.
func withThreadCountID(id int) threadcountOption {
	return func(m *ThreadCountMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreadCount
		)
		m.oldValue = func(ctx context.Context) (*ThreadCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreadCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreadCount sets the old ThreadCount of the mutation.
func withThreadCount(node *ThreadCount) threadcountOption {
	return func(m *ThreadCountMutation) {
		m.oldValue = func(context.Context) (*ThreadCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreadCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReplyCount sets the "reply_count" field.
func (m *ThreadCountMutation) SetReplyCount(i int) {
	m.reply_count = &i
	m.addreply_count = nil
}

// ReplyCount returns the value of the "reply_count" field in the mutation.
func (m *ThreadCountMutation) ReplyCount() (r int, exists bool) {
	v := m.reply_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyCount returns the old "reply_count" field's value of the ThreadCount entity.
// If the ThreadCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCountMutation) OldReplyCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyCount: %w", err)
	}
	return oldValue.ReplyCount, nil
}

// AddReplyCount adds i to the "reply_count" field.
func (m *ThreadCountMutation) AddReplyCount(i int) {
	if m.addreply_count != nil {
		*m.addreply_count += i
	} else {
		m.addreply_count = &i
	}
}

// AddedReplyCount returns the value that was added to the "reply_count" field in this mutation.
func (m *ThreadCountMutation) AddedReplyCount() (r int, exists bool) {
	v := m.addreply_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplyCount resets all changes to the "reply_count" field.
func (m *ThreadCountMutation) ResetReplyCount() {
	m.reply_count = nil
	m.addreply_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *ThreadCountMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *ThreadCountMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the ThreadCount entity.
// If the ThreadCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadCountMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *ThreadCountMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *ThreadCountMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *ThreadCountMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// Where appends a list predicates to the ThreadCountMutation builder.
func (m *ThreadCountMutation) Where(ps ...predicate.ThreadCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadCount).
func (m *ThreadCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.reply_count != nil {
		fields = append(fields, threadcount.FieldReplyCount)
	}
	if m.like_count != nil {
		fields = append(fields, threadcount.FieldLikeCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.ReplyCount()
	case threadcount.FieldLikeCount:
		return m.LikeCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.OldReplyCount(ctx)
	case threadcount.FieldLikeCount:
		return m.OldLikeCount(ctx)
	}
	return nil, fmt.Errorf("unknown ThreadCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadcount.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyCount(v)
		return nil
	case threadcount.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadCountMutation) AddedFields() []string {
	var fields []string
	if m.addreply_count != nil {
		fields = append(fields, threadcount.FieldReplyCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, threadcount.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threadcount.FieldReplyCount:
		return m.AddedReplyCount()
	case threadcount.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threadcount.FieldReplyCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplyCount(v)
		return nil
	case threadcount.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadCountMutation) ResetField(name string) error {
	switch name {
	case threadcount.FieldReplyCount:
		m.ResetReplyCount()
		return nil
	case threadcount.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	}
	return fmt.Errorf("unknown ThreadCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadCountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadCountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadCountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ThreadCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadCountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ThreadCount edge %s", name)
}

// UserAccountMutation represents an operation that mutates the UserAccount nodes in the graph.
type UserAccountMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	email                  *string
	username               *string
	password               *string
	is_verified            *bool
	is_private             *bool
	is_email_verified      *bool
	clearedFields          map[string]struct{}
	profile                *int
	clearedprofile         bool
	followers              map[int]struct{}
	removedfollowers       map[int]struct{}
	clearedfollowers       bool
	following              map[int]struct{}
	removedfollowing       map[int]struct{}
	clearedfollowing       bool
	blocked_by             map[int]struct{}
	removedblocked_by      map[int]struct{}
	clearedblocked_by      bool
	blocked_user           map[int]struct{}
	removedblocked_user    map[int]struct{}
	clearedblocked_user    bool
	user_count_info        *int
	cleareduser_count_info bool
	done                   bool
	oldValue               func(context.Context) (*UserAccount, error)
	predicates             []predicate.UserAccount
}

var _ ent.Mutation = (*UserAccountMutation)(nil)

// useraccountOption allows management of the mutation configuration using functional options.
type useraccountOption func(*UserAccountMutation)

// newUserAccountMutation creates new mutation for the UserAccount entity.
func newUserAccountMutation(c config, op Op, opts ...useraccountOption) *UserAccountMutation {
	m := &UserAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAccountID sets the ID field of the mutation.
func withUserAccountID(id int) useraccountOption {
	return func(m *UserAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAccount
		)
		m.oldValue = func(ctx context.Context) (*UserAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAccount sets the old UserAccount of the mutation.
func withUserAccount(node *UserAccount) useraccountOption {
	return func(m *UserAccountMutation) {
		m.oldValue = func(context.Context) (*UserAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserAccountMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserAccountMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserAccountMutation) ResetPassword() {
	m.password = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserAccountMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserAccountMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserAccountMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetIsPrivate sets the "is_private" field.
func (m *UserAccountMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *UserAccountMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *UserAccountMutation) ResetIsPrivate() {
	m.is_private = nil
}

// SetIsEmailVerified sets the "is_email_verified" field.
func (m *UserAccountMutation) SetIsEmailVerified(b bool) {
	m.is_email_verified = &b
}

// IsEmailVerified returns the value of the "is_email_verified" field in the mutation.
func (m *UserAccountMutation) IsEmailVerified() (r bool, exists bool) {
	v := m.is_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEmailVerified returns the old "is_email_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEmailVerified: %w", err)
	}
	return oldValue.IsEmailVerified, nil
}

// ResetIsEmailVerified resets all changes to the "is_email_verified" field.
func (m *UserAccountMutation) ResetIsEmailVerified() {
	m.is_email_verified = nil
}

// SetProfileID sets the "profile" edge to the UserProfile entity by id.
func (m *UserAccountMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the UserProfile entity.
func (m *UserAccountMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the UserProfile entity was cleared.
func (m *UserAccountMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserAccountMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserAccountMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserAccountMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddFollowerIDs adds the "followers" edge to the UserAccount entity by ids.
func (m *UserAccountMutation) AddFollowerIDs(ids ...int) {
	if m.followers == nil {
		m.followers = make(map[int]struct{})
	}
	for i := range ids {
		m.followers[ids[i]] = struct{}{}
	}
}

// ClearFollowers clears the "followers" edge to the UserAccount entity.
func (m *UserAccountMutation) ClearFollowers() {
	m.clearedfollowers = true
}

// FollowersCleared reports if the "followers" edge to the UserAccount entity was cleared.
func (m *UserAccountMutation) FollowersCleared() bool {
	return m.clearedfollowers
}

// RemoveFollowerIDs removes the "followers" edge to the UserAccount entity by IDs.
func (m *UserAccountMutation) RemoveFollowerIDs(ids ...int) {
	if m.removedfollowers == nil {
		m.removedfollowers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followers, ids[i])
		m.removedfollowers[ids[i]] = struct{}{}
	}
}

// RemovedFollowers returns the removed IDs of the "followers" edge to the UserAccount entity.
func (m *UserAccountMutation) RemovedFollowersIDs() (ids []int) {
	for id := range m.removedfollowers {
		ids = append(ids, id)
	}
	return
}

// FollowersIDs returns the "followers" edge IDs in the mutation.
func (m *UserAccountMutation) FollowersIDs() (ids []int) {
	for id := range m.followers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowers resets all changes to the "followers" edge.
func (m *UserAccountMutation) ResetFollowers() {
	m.followers = nil
	m.clearedfollowers = false
	m.removedfollowers = nil
}

// AddFollowingIDs adds the "following" edge to the UserAccount entity by ids.
func (m *UserAccountMutation) AddFollowingIDs(ids ...int) {
	if m.following == nil {
		m.following = make(map[int]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the UserAccount entity.
func (m *UserAccountMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the UserAccount entity was cleared.
func (m *UserAccountMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the UserAccount entity by IDs.
func (m *UserAccountMutation) RemoveFollowingIDs(ids ...int) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the UserAccount entity.
func (m *UserAccountMutation) RemovedFollowingIDs() (ids []int) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *UserAccountMutation) FollowingIDs() (ids []int) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *UserAccountMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddBlockedByIDs adds the "blocked_by" edge to the UserAccount entity by ids.
func (m *UserAccountMutation) AddBlockedByIDs(ids ...int) {
	if m.blocked_by == nil {
		m.blocked_by = make(map[int]struct{})
	}
	for i := range ids {
		m.blocked_by[ids[i]] = struct{}{}
	}
}

// ClearBlockedBy clears the "blocked_by" edge to the UserAccount entity.
func (m *UserAccountMutation) ClearBlockedBy() {
	m.clearedblocked_by = true
}

// BlockedByCleared reports if the "blocked_by" edge to the UserAccount entity was cleared.
func (m *UserAccountMutation) BlockedByCleared() bool {
	return m.clearedblocked_by
}

// RemoveBlockedByIDs removes the "blocked_by" edge to the UserAccount entity by IDs.
func (m *UserAccountMutation) RemoveBlockedByIDs(ids ...int) {
	if m.removedblocked_by == nil {
		m.removedblocked_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocked_by, ids[i])
		m.removedblocked_by[ids[i]] = struct{}{}
	}
}

// RemovedBlockedBy returns the removed IDs of the "blocked_by" edge to the UserAccount entity.
func (m *UserAccountMutation) RemovedBlockedByIDs() (ids []int) {
	for id := range m.removedblocked_by {
		ids = append(ids, id)
	}
	return
}

// BlockedByIDs returns the "blocked_by" edge IDs in the mutation.
func (m *UserAccountMutation) BlockedByIDs() (ids []int) {
	for id := range m.blocked_by {
		ids = append(ids, id)
	}
	return
}

// ResetBlockedBy resets all changes to the "blocked_by" edge.
func (m *UserAccountMutation) ResetBlockedBy() {
	m.blocked_by = nil
	m.clearedblocked_by = false
	m.removedblocked_by = nil
}

// AddBlockedUserIDs adds the "blocked_user" edge to the UserAccount entity by ids.
func (m *UserAccountMutation) AddBlockedUserIDs(ids ...int) {
	if m.blocked_user == nil {
		m.blocked_user = make(map[int]struct{})
	}
	for i := range ids {
		m.blocked_user[ids[i]] = struct{}{}
	}
}

// ClearBlockedUser clears the "blocked_user" edge to the UserAccount entity.
func (m *UserAccountMutation) ClearBlockedUser() {
	m.clearedblocked_user = true
}

// BlockedUserCleared reports if the "blocked_user" edge to the UserAccount entity was cleared.
func (m *UserAccountMutation) BlockedUserCleared() bool {
	return m.clearedblocked_user
}

// RemoveBlockedUserIDs removes the "blocked_user" edge to the UserAccount entity by IDs.
func (m *UserAccountMutation) RemoveBlockedUserIDs(ids ...int) {
	if m.removedblocked_user == nil {
		m.removedblocked_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.blocked_user, ids[i])
		m.removedblocked_user[ids[i]] = struct{}{}
	}
}

// RemovedBlockedUser returns the removed IDs of the "blocked_user" edge to the UserAccount entity.
func (m *UserAccountMutation) RemovedBlockedUserIDs() (ids []int) {
	for id := range m.removedblocked_user {
		ids = append(ids, id)
	}
	return
}

// BlockedUserIDs returns the "blocked_user" edge IDs in the mutation.
func (m *UserAccountMutation) BlockedUserIDs() (ids []int) {
	for id := range m.blocked_user {
		ids = append(ids, id)
	}
	return
}

// ResetBlockedUser resets all changes to the "blocked_user" edge.
func (m *UserAccountMutation) ResetBlockedUser() {
	m.blocked_user = nil
	m.clearedblocked_user = false
	m.removedblocked_user = nil
}

// SetUserCountInfoID sets the "user_count_info" edge to the UserCount entity by id.
func (m *UserAccountMutation) SetUserCountInfoID(id int) {
	m.user_count_info = &id
}

// ClearUserCountInfo clears the "user_count_info" edge to the UserCount entity.
func (m *UserAccountMutation) ClearUserCountInfo() {
	m.cleareduser_count_info = true
}

// UserCountInfoCleared reports if the "user_count_info" edge to the UserCount entity was cleared.
func (m *UserAccountMutation) UserCountInfoCleared() bool {
	return m.cleareduser_count_info
}

// UserCountInfoID returns the "user_count_info" edge ID in the mutation.
func (m *UserAccountMutation) UserCountInfoID() (id int, exists bool) {
	if m.user_count_info != nil {
		return *m.user_count_info, true
	}
	return
}

// UserCountInfoIDs returns the "user_count_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserCountInfoID instead. It exists only for internal usage by the builders.
func (m *UserAccountMutation) UserCountInfoIDs() (ids []int) {
	if id := m.user_count_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserCountInfo resets all changes to the "user_count_info" edge.
func (m *UserAccountMutation) ResetUserCountInfo() {
	m.user_count_info = nil
	m.cleareduser_count_info = false
}

// Where appends a list predicates to the UserAccountMutation builder.
func (m *UserAccountMutation) Where(ps ...predicate.UserAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAccount).
func (m *UserAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, useraccount.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, useraccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, useraccount.FieldPassword)
	}
	if m.is_verified != nil {
		fields = append(fields, useraccount.FieldIsVerified)
	}
	if m.is_private != nil {
		fields = append(fields, useraccount.FieldIsPrivate)
	}
	if m.is_email_verified != nil {
		fields = append(fields, useraccount.FieldIsEmailVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraccount.FieldEmail:
		return m.Email()
	case useraccount.FieldUsername:
		return m.Username()
	case useraccount.FieldPassword:
		return m.Password()
	case useraccount.FieldIsVerified:
		return m.IsVerified()
	case useraccount.FieldIsPrivate:
		return m.IsPrivate()
	case useraccount.FieldIsEmailVerified:
		return m.IsEmailVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraccount.FieldEmail:
		return m.OldEmail(ctx)
	case useraccount.FieldUsername:
		return m.OldUsername(ctx)
	case useraccount.FieldPassword:
		return m.OldPassword(ctx)
	case useraccount.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case useraccount.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case useraccount.FieldIsEmailVerified:
		return m.OldIsEmailVerified(ctx)
	}
	return nil, fmt.Errorf("unknown UserAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case useraccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case useraccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case useraccount.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case useraccount.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case useraccount.FieldIsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEmailVerified(v)
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAccountMutation) ResetField(name string) error {
	switch name {
	case useraccount.FieldEmail:
		m.ResetEmail()
		return nil
	case useraccount.FieldUsername:
		m.ResetUsername()
		return nil
	case useraccount.FieldPassword:
		m.ResetPassword()
		return nil
	case useraccount.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case useraccount.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case useraccount.FieldIsEmailVerified:
		m.ResetIsEmailVerified()
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.profile != nil {
		edges = append(edges, useraccount.EdgeProfile)
	}
	if m.followers != nil {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.following != nil {
		edges = append(edges, useraccount.EdgeFollowing)
	}
	if m.blocked_by != nil {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.blocked_user != nil {
		edges = append(edges, useraccount.EdgeBlockedUser)
	}
	if m.user_count_info != nil {
		edges = append(edges, useraccount.EdgeUserCountInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraccount.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case useraccount.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.followers))
		for id := range m.followers {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.blocked_by))
		for id := range m.blocked_by {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedUser:
		ids := make([]ent.Value, 0, len(m.blocked_user))
		for id := range m.blocked_user {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeUserCountInfo:
		if id := m.user_count_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedfollowers != nil {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.removedfollowing != nil {
		edges = append(edges, useraccount.EdgeFollowing)
	}
	if m.removedblocked_by != nil {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.removedblocked_user != nil {
		edges = append(edges, useraccount.EdgeBlockedUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case useraccount.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.removedfollowers))
		for id := range m.removedfollowers {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedBy:
		ids := make([]ent.Value, 0, len(m.removedblocked_by))
		for id := range m.removedblocked_by {
			ids = append(ids, id)
		}
		return ids
	case useraccount.EdgeBlockedUser:
		ids := make([]ent.Value, 0, len(m.removedblocked_user))
		for id := range m.removedblocked_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedprofile {
		edges = append(edges, useraccount.EdgeProfile)
	}
	if m.clearedfollowers {
		edges = append(edges, useraccount.EdgeFollowers)
	}
	if m.clearedfollowing {
		edges = append(edges, useraccount.EdgeFollowing)
	}
	if m.clearedblocked_by {
		edges = append(edges, useraccount.EdgeBlockedBy)
	}
	if m.clearedblocked_user {
		edges = append(edges, useraccount.EdgeBlockedUser)
	}
	if m.cleareduser_count_info {
		edges = append(edges, useraccount.EdgeUserCountInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case useraccount.EdgeProfile:
		return m.clearedprofile
	case useraccount.EdgeFollowers:
		return m.clearedfollowers
	case useraccount.EdgeFollowing:
		return m.clearedfollowing
	case useraccount.EdgeBlockedBy:
		return m.clearedblocked_by
	case useraccount.EdgeBlockedUser:
		return m.clearedblocked_user
	case useraccount.EdgeUserCountInfo:
		return m.cleareduser_count_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAccountMutation) ClearEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ClearProfile()
		return nil
	case useraccount.EdgeUserCountInfo:
		m.ClearUserCountInfo()
		return nil
	}
	return fmt.Errorf("unknown UserAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAccountMutation) ResetEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ResetProfile()
		return nil
	case useraccount.EdgeFollowers:
		m.ResetFollowers()
		return nil
	case useraccount.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case useraccount.EdgeBlockedBy:
		m.ResetBlockedBy()
		return nil
	case useraccount.EdgeBlockedUser:
		m.ResetBlockedUser()
		return nil
	case useraccount.EdgeUserCountInfo:
		m.ResetUserCountInfo()
		return nil
	}
	return fmt.Errorf("unknown UserAccount edge %s", name)
}

// UserCountMutation represents an operation that mutates the UserCount nodes in the graph.
type UserCountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	follower_count      *int
	addfollower_count   *int
	followings_count    *int
	addfollowings_count *int
	clearedFields       map[string]struct{}
	user                map[int]struct{}
	removeduser         map[int]struct{}
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*UserCount, error)
	predicates          []predicate.UserCount
}

var _ ent.Mutation = (*UserCountMutation)(nil)

// usercountOption allows management of the mutation configuration using functional options.
type usercountOption func(*UserCountMutation)

// newUserCountMutation creates new mutation for the UserCount entity.
func newUserCountMutation(c config, op Op, opts ...usercountOption) *UserCountMutation {
	m := &UserCountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCountID sets the ID field of the mutation.
func withUserCountID(id int) usercountOption {
	return func(m *UserCountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCount
		)
		m.oldValue = func(ctx context.Context) (*UserCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCount sets the old UserCount of the mutation.
func withUserCount(node *UserCount) usercountOption {
	return func(m *UserCountMutation) {
		m.oldValue = func(context.Context) (*UserCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFollowerCount sets the "follower_count" field.
func (m *UserCountMutation) SetFollowerCount(i int) {
	m.follower_count = &i
	m.addfollower_count = nil
}

// FollowerCount returns the value of the "follower_count" field in the mutation.
func (m *UserCountMutation) FollowerCount() (r int, exists bool) {
	v := m.follower_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerCount returns the old "follower_count" field's value of the UserCount entity.
// If the UserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCountMutation) OldFollowerCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerCount: %w", err)
	}
	return oldValue.FollowerCount, nil
}

// AddFollowerCount adds i to the "follower_count" field.
func (m *UserCountMutation) AddFollowerCount(i int) {
	if m.addfollower_count != nil {
		*m.addfollower_count += i
	} else {
		m.addfollower_count = &i
	}
}

// AddedFollowerCount returns the value that was added to the "follower_count" field in this mutation.
func (m *UserCountMutation) AddedFollowerCount() (r int, exists bool) {
	v := m.addfollower_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerCount resets all changes to the "follower_count" field.
func (m *UserCountMutation) ResetFollowerCount() {
	m.follower_count = nil
	m.addfollower_count = nil
}

// SetFollowingsCount sets the "followings_count" field.
func (m *UserCountMutation) SetFollowingsCount(i int) {
	m.followings_count = &i
	m.addfollowings_count = nil
}

// FollowingsCount returns the value of the "followings_count" field in the mutation.
func (m *UserCountMutation) FollowingsCount() (r int, exists bool) {
	v := m.followings_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingsCount returns the old "followings_count" field's value of the UserCount entity.
// If the UserCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCountMutation) OldFollowingsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingsCount: %w", err)
	}
	return oldValue.FollowingsCount, nil
}

// AddFollowingsCount adds i to the "followings_count" field.
func (m *UserCountMutation) AddFollowingsCount(i int) {
	if m.addfollowings_count != nil {
		*m.addfollowings_count += i
	} else {
		m.addfollowings_count = &i
	}
}

// AddedFollowingsCount returns the value that was added to the "followings_count" field in this mutation.
func (m *UserCountMutation) AddedFollowingsCount() (r int, exists bool) {
	v := m.addfollowings_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingsCount resets all changes to the "followings_count" field.
func (m *UserCountMutation) ResetFollowingsCount() {
	m.followings_count = nil
	m.addfollowings_count = nil
}

// AddUserIDs adds the "user" edge to the UserAccount entity by ids.
func (m *UserCountMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the UserAccount entity.
func (m *UserCountMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the UserAccount entity was cleared.
func (m *UserCountMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the UserAccount entity by IDs.
func (m *UserCountMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the UserAccount entity.
func (m *UserCountMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserCountMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserCountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the UserCountMutation builder.
func (m *UserCountMutation) Where(ps ...predicate.UserCount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCount).
func (m *UserCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.follower_count != nil {
		fields = append(fields, usercount.FieldFollowerCount)
	}
	if m.followings_count != nil {
		fields = append(fields, usercount.FieldFollowingsCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.FollowerCount()
	case usercount.FieldFollowingsCount:
		return m.FollowingsCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.OldFollowerCount(ctx)
	case usercount.FieldFollowingsCount:
		return m.OldFollowingsCount(ctx)
	}
	return nil, fmt.Errorf("unknown UserCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercount.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerCount(v)
		return nil
	case usercount.FieldFollowingsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingsCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCountMutation) AddedFields() []string {
	var fields []string
	if m.addfollower_count != nil {
		fields = append(fields, usercount.FieldFollowerCount)
	}
	if m.addfollowings_count != nil {
		fields = append(fields, usercount.FieldFollowingsCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercount.FieldFollowerCount:
		return m.AddedFollowerCount()
	case usercount.FieldFollowingsCount:
		return m.AddedFollowingsCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercount.FieldFollowerCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerCount(v)
		return nil
	case usercount.FieldFollowingsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingsCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCountMutation) ResetField(name string) error {
	switch name {
	case usercount.FieldFollowerCount:
		m.ResetFollowerCount()
		return nil
	case usercount.FieldFollowingsCount:
		m.ResetFollowingsCount()
		return nil
	}
	return fmt.Errorf("unknown UserCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usercount.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercount.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser != nil {
		edges = append(edges, usercount.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usercount.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usercount.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCountMutation) EdgeCleared(name string) bool {
	switch name {
	case usercount.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCountMutation) ResetEdge(name string) error {
	switch name {
	case usercount.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserCount edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	display_name           *string
	bio                    *string
	clearedFields          map[string]struct{}
	account                *int
	clearedaccount         bool
	profile_picture        *int
	clearedprofile_picture bool
	banner                 *int
	clearedbanner          bool
	done                   bool
	oldValue               func(context.Context) (*UserProfile, error)
	predicates             []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id int) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplayName sets the "display_name" field.
func (m *UserProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserProfileMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetBio sets the "bio" field.
func (m *UserProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *UserProfileMutation) ResetBio() {
	m.bio = nil
}

// SetAccountID sets the "account" edge to the UserAccount entity by id.
func (m *UserProfileMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the UserAccount entity.
func (m *UserProfileMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the UserAccount entity was cleared.
func (m *UserProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *UserProfileMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetProfilePictureID sets the "profile_picture" edge to the Media entity by id.
func (m *UserProfileMutation) SetProfilePictureID(id int) {
	m.profile_picture = &id
}

// ClearProfilePicture clears the "profile_picture" edge to the Media entity.
func (m *UserProfileMutation) ClearProfilePicture() {
	m.clearedprofile_picture = true
}

// ProfilePictureCleared reports if the "profile_picture" edge to the Media entity was cleared.
func (m *UserProfileMutation) ProfilePictureCleared() bool {
	return m.clearedprofile_picture
}

// ProfilePictureID returns the "profile_picture" edge ID in the mutation.
func (m *UserProfileMutation) ProfilePictureID() (id int, exists bool) {
	if m.profile_picture != nil {
		return *m.profile_picture, true
	}
	return
}

// ProfilePictureIDs returns the "profile_picture" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfilePictureID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) ProfilePictureIDs() (ids []int) {
	if id := m.profile_picture; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfilePicture resets all changes to the "profile_picture" edge.
func (m *UserProfileMutation) ResetProfilePicture() {
	m.profile_picture = nil
	m.clearedprofile_picture = false
}

// SetBannerID sets the "banner" edge to the Media entity by id.
func (m *UserProfileMutation) SetBannerID(id int) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Media entity.
func (m *UserProfileMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Media entity was cleared.
func (m *UserProfileMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *UserProfileMutation) BannerID() (id int, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) BannerIDs() (ids []int) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *UserProfileMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.display_name != nil {
		fields = append(fields, userprofile.FieldDisplayName)
	}
	if m.bio != nil {
		fields = append(fields, userprofile.FieldBio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.DisplayName()
	case userprofile.FieldBio:
		return m.Bio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case userprofile.FieldBio:
		return m.OldBio(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case userprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case userprofile.FieldBio:
		m.ResetBio()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.account != nil {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.profile_picture != nil {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.banner != nil {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeProfilePicture:
		if id := m.profile_picture; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccount {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.clearedprofile_picture {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.clearedbanner {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeAccount:
		return m.clearedaccount
	case userprofile.EdgeProfilePicture:
		return m.clearedprofile_picture
	case userprofile.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ClearAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ClearProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ResetAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ResetProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
