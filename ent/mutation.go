// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/0xfzz/tuwitt/ent/media"
	"github.com/0xfzz/tuwitt/ent/predicate"
	"github.com/0xfzz/tuwitt/ent/thread"
	"github.com/0xfzz/tuwitt/ent/useraccount"
	"github.com/0xfzz/tuwitt/ent/userprofile"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMedia       = "Media"
	TypeThread      = "Thread"
	TypeUser        = "User"
	TypeUserAccount = "UserAccount"
	TypeUserProfile = "UserProfile"
)

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_path                        *string
	category                     *media.Category
	clearedFields                map[string]struct{}
	threads                      map[int]struct{}
	removedthreads               map[int]struct{}
	clearedthreads               bool
	owner_profile_picture        map[int]struct{}
	removedowner_profile_picture map[int]struct{}
	clearedowner_profile_picture bool
	owner_banner                 map[int]struct{}
	removedowner_banner          map[int]struct{}
	clearedowner_banner          bool
	done                         bool
	oldValue                     func(context.Context) (*Media, error)
	predicates                   []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id int) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *MediaMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MediaMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *MediaMutation) ResetPath() {
	m._path = nil
}

// SetCategory sets the "category" field.
func (m *MediaMutation) SetCategory(value media.Category) {
	m.category = &value
}

// Category returns the value of the "category" field in the mutation.
func (m *MediaMutation) Category() (r media.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCategory(ctx context.Context) (v media.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *MediaMutation) ResetCategory() {
	m.category = nil
}

// AddThreadIDs adds the "threads" edge to the Thread entity by ids.
func (m *MediaMutation) AddThreadIDs(ids ...int) {
	if m.threads == nil {
		m.threads = make(map[int]struct{})
	}
	for i := range ids {
		m.threads[ids[i]] = struct{}{}
	}
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *MediaMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *MediaMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// RemoveThreadIDs removes the "threads" edge to the Thread entity by IDs.
func (m *MediaMutation) RemoveThreadIDs(ids ...int) {
	if m.removedthreads == nil {
		m.removedthreads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.threads, ids[i])
		m.removedthreads[ids[i]] = struct{}{}
	}
}

// RemovedThreads returns the removed IDs of the "threads" edge to the Thread entity.
func (m *MediaMutation) RemovedThreadsIDs() (ids []int) {
	for id := range m.removedthreads {
		ids = append(ids, id)
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
func (m *MediaMutation) ThreadsIDs() (ids []int) {
	for id := range m.threads {
		ids = append(ids, id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *MediaMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
	m.removedthreads = nil
}

// AddOwnerProfilePictureIDs adds the "owner_profile_picture" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerProfilePictureIDs(ids ...int) {
	if m.owner_profile_picture == nil {
		m.owner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_profile_picture[ids[i]] = struct{}{}
	}
}

// ClearOwnerProfilePicture clears the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerProfilePicture() {
	m.clearedowner_profile_picture = true
}

// OwnerProfilePictureCleared reports if the "owner_profile_picture" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerProfilePictureCleared() bool {
	return m.clearedowner_profile_picture
}

// RemoveOwnerProfilePictureIDs removes the "owner_profile_picture" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerProfilePictureIDs(ids ...int) {
	if m.removedowner_profile_picture == nil {
		m.removedowner_profile_picture = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_profile_picture, ids[i])
		m.removedowner_profile_picture[ids[i]] = struct{}{}
	}
}

// RemovedOwnerProfilePicture returns the removed IDs of the "owner_profile_picture" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerProfilePictureIDs() (ids []int) {
	for id := range m.removedowner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// OwnerProfilePictureIDs returns the "owner_profile_picture" edge IDs in the mutation.
func (m *MediaMutation) OwnerProfilePictureIDs() (ids []int) {
	for id := range m.owner_profile_picture {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerProfilePicture resets all changes to the "owner_profile_picture" edge.
func (m *MediaMutation) ResetOwnerProfilePicture() {
	m.owner_profile_picture = nil
	m.clearedowner_profile_picture = false
	m.removedowner_profile_picture = nil
}

// AddOwnerBannerIDs adds the "owner_banner" edge to the UserProfile entity by ids.
func (m *MediaMutation) AddOwnerBannerIDs(ids ...int) {
	if m.owner_banner == nil {
		m.owner_banner = make(map[int]struct{})
	}
	for i := range ids {
		m.owner_banner[ids[i]] = struct{}{}
	}
}

// ClearOwnerBanner clears the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) ClearOwnerBanner() {
	m.clearedowner_banner = true
}

// OwnerBannerCleared reports if the "owner_banner" edge to the UserProfile entity was cleared.
func (m *MediaMutation) OwnerBannerCleared() bool {
	return m.clearedowner_banner
}

// RemoveOwnerBannerIDs removes the "owner_banner" edge to the UserProfile entity by IDs.
func (m *MediaMutation) RemoveOwnerBannerIDs(ids ...int) {
	if m.removedowner_banner == nil {
		m.removedowner_banner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owner_banner, ids[i])
		m.removedowner_banner[ids[i]] = struct{}{}
	}
}

// RemovedOwnerBanner returns the removed IDs of the "owner_banner" edge to the UserProfile entity.
func (m *MediaMutation) RemovedOwnerBannerIDs() (ids []int) {
	for id := range m.removedowner_banner {
		ids = append(ids, id)
	}
	return
}

// OwnerBannerIDs returns the "owner_banner" edge IDs in the mutation.
func (m *MediaMutation) OwnerBannerIDs() (ids []int) {
	for id := range m.owner_banner {
		ids = append(ids, id)
	}
	return
}

// ResetOwnerBanner resets all changes to the "owner_banner" edge.
func (m *MediaMutation) ResetOwnerBanner() {
	m.owner_banner = nil
	m.clearedowner_banner = false
	m.removedowner_banner = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._path != nil {
		fields = append(fields, media.FieldPath)
	}
	if m.category != nil {
		fields = append(fields, media.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldPath:
		return m.Path()
	case media.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldPath:
		return m.OldPath(ctx)
	case media.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case media.FieldCategory:
		v, ok := value.(media.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldPath:
		m.ResetPath()
		return nil
	case media.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.threads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.owner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.owner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.threads))
		for id := range m.threads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.owner_profile_picture))
		for id := range m.owner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.owner_banner))
		for id := range m.owner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedthreads != nil {
		edges = append(edges, media.EdgeThreads)
	}
	if m.removedowner_profile_picture != nil {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.removedowner_banner != nil {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeThreads:
		ids := make([]ent.Value, 0, len(m.removedthreads))
		for id := range m.removedthreads {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerProfilePicture:
		ids := make([]ent.Value, 0, len(m.removedowner_profile_picture))
		for id := range m.removedowner_profile_picture {
			ids = append(ids, id)
		}
		return ids
	case media.EdgeOwnerBanner:
		ids := make([]ent.Value, 0, len(m.removedowner_banner))
		for id := range m.removedowner_banner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedthreads {
		edges = append(edges, media.EdgeThreads)
	}
	if m.clearedowner_profile_picture {
		edges = append(edges, media.EdgeOwnerProfilePicture)
	}
	if m.clearedowner_banner {
		edges = append(edges, media.EdgeOwnerBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeThreads:
		return m.clearedthreads
	case media.EdgeOwnerProfilePicture:
		return m.clearedowner_profile_picture
	case media.EdgeOwnerBanner:
		return m.clearedowner_banner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeThreads:
		m.ResetThreads()
		return nil
	case media.EdgeOwnerProfilePicture:
		m.ResetOwnerProfilePicture()
		return nil
	case media.EdgeOwnerBanner:
		m.ResetOwnerBanner()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	content              *string
	is_comment_disabled  *bool
	visibility           *thread.Visibility
	status               *thread.Status
	is_deleted           *bool
	clearedFields        map[string]struct{}
	parent_thread        *int
	clearedparent_thread bool
	child_threads        map[int]struct{}
	removedchild_threads map[int]struct{}
	clearedchild_threads bool
	images               map[int]struct{}
	removedimages        map[int]struct{}
	clearedimages        bool
	done                 bool
	oldValue             func(context.Context) (*Thread, error)
	predicates           []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *ThreadMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ThreadMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ThreadMutation) ResetContent() {
	m.content = nil
}

// SetIsCommentDisabled sets the "is_comment_disabled" field.
func (m *ThreadMutation) SetIsCommentDisabled(b bool) {
	m.is_comment_disabled = &b
}

// IsCommentDisabled returns the value of the "is_comment_disabled" field in the mutation.
func (m *ThreadMutation) IsCommentDisabled() (r bool, exists bool) {
	v := m.is_comment_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCommentDisabled returns the old "is_comment_disabled" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsCommentDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCommentDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCommentDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCommentDisabled: %w", err)
	}
	return oldValue.IsCommentDisabled, nil
}

// ResetIsCommentDisabled resets all changes to the "is_comment_disabled" field.
func (m *ThreadMutation) ResetIsCommentDisabled() {
	m.is_comment_disabled = nil
}

// SetVisibility sets the "visibility" field.
func (m *ThreadMutation) SetVisibility(t thread.Visibility) {
	m.visibility = &t
}

// Visibility returns the value of the "visibility" field in the mutation.
func (m *ThreadMutation) Visibility() (r thread.Visibility, exists bool) {
	v := m.visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibility returns the old "visibility" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldVisibility(ctx context.Context) (v thread.Visibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibility: %w", err)
	}
	return oldValue.Visibility, nil
}

// ResetVisibility resets all changes to the "visibility" field.
func (m *ThreadMutation) ResetVisibility() {
	m.visibility = nil
}

// SetStatus sets the "status" field.
func (m *ThreadMutation) SetStatus(t thread.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *ThreadMutation) Status() (r thread.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldStatus(ctx context.Context) (v thread.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ThreadMutation) ResetStatus() {
	m.status = nil
}

// SetIsDeleted sets the "is_deleted" field.
func (m *ThreadMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *ThreadMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *ThreadMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetParentThreadID sets the "parent_thread" edge to the Thread entity by id.
func (m *ThreadMutation) SetParentThreadID(id int) {
	m.parent_thread = &id
}

// ClearParentThread clears the "parent_thread" edge to the Thread entity.
func (m *ThreadMutation) ClearParentThread() {
	m.clearedparent_thread = true
}

// ParentThreadCleared reports if the "parent_thread" edge to the Thread entity was cleared.
func (m *ThreadMutation) ParentThreadCleared() bool {
	return m.clearedparent_thread
}

// ParentThreadID returns the "parent_thread" edge ID in the mutation.
func (m *ThreadMutation) ParentThreadID() (id int, exists bool) {
	if m.parent_thread != nil {
		return *m.parent_thread, true
	}
	return
}

// ParentThreadIDs returns the "parent_thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) ParentThreadIDs() (ids []int) {
	if id := m.parent_thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentThread resets all changes to the "parent_thread" edge.
func (m *ThreadMutation) ResetParentThread() {
	m.parent_thread = nil
	m.clearedparent_thread = false
}

// AddChildThreadIDs adds the "child_threads" edge to the Thread entity by ids.
func (m *ThreadMutation) AddChildThreadIDs(ids ...int) {
	if m.child_threads == nil {
		m.child_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.child_threads[ids[i]] = struct{}{}
	}
}

// ClearChildThreads clears the "child_threads" edge to the Thread entity.
func (m *ThreadMutation) ClearChildThreads() {
	m.clearedchild_threads = true
}

// ChildThreadsCleared reports if the "child_threads" edge to the Thread entity was cleared.
func (m *ThreadMutation) ChildThreadsCleared() bool {
	return m.clearedchild_threads
}

// RemoveChildThreadIDs removes the "child_threads" edge to the Thread entity by IDs.
func (m *ThreadMutation) RemoveChildThreadIDs(ids ...int) {
	if m.removedchild_threads == nil {
		m.removedchild_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.child_threads, ids[i])
		m.removedchild_threads[ids[i]] = struct{}{}
	}
}

// RemovedChildThreads returns the removed IDs of the "child_threads" edge to the Thread entity.
func (m *ThreadMutation) RemovedChildThreadsIDs() (ids []int) {
	for id := range m.removedchild_threads {
		ids = append(ids, id)
	}
	return
}

// ChildThreadsIDs returns the "child_threads" edge IDs in the mutation.
func (m *ThreadMutation) ChildThreadsIDs() (ids []int) {
	for id := range m.child_threads {
		ids = append(ids, id)
	}
	return
}

// ResetChildThreads resets all changes to the "child_threads" edge.
func (m *ThreadMutation) ResetChildThreads() {
	m.child_threads = nil
	m.clearedchild_threads = false
	m.removedchild_threads = nil
}

// AddImageIDs adds the "images" edge to the Media entity by ids.
func (m *ThreadMutation) AddImageIDs(ids ...int) {
	if m.images == nil {
		m.images = make(map[int]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the Media entity.
func (m *ThreadMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the Media entity was cleared.
func (m *ThreadMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the Media entity by IDs.
func (m *ThreadMutation) RemoveImageIDs(ids ...int) {
	if m.removedimages == nil {
		m.removedimages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the Media entity.
func (m *ThreadMutation) RemovedImagesIDs() (ids []int) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ThreadMutation) ImagesIDs() (ids []int) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ThreadMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.content != nil {
		fields = append(fields, thread.FieldContent)
	}
	if m.is_comment_disabled != nil {
		fields = append(fields, thread.FieldIsCommentDisabled)
	}
	if m.visibility != nil {
		fields = append(fields, thread.FieldVisibility)
	}
	if m.status != nil {
		fields = append(fields, thread.FieldStatus)
	}
	if m.is_deleted != nil {
		fields = append(fields, thread.FieldIsDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldContent:
		return m.Content()
	case thread.FieldIsCommentDisabled:
		return m.IsCommentDisabled()
	case thread.FieldVisibility:
		return m.Visibility()
	case thread.FieldStatus:
		return m.Status()
	case thread.FieldIsDeleted:
		return m.IsDeleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldContent:
		return m.OldContent(ctx)
	case thread.FieldIsCommentDisabled:
		return m.OldIsCommentDisabled(ctx)
	case thread.FieldVisibility:
		return m.OldVisibility(ctx)
	case thread.FieldStatus:
		return m.OldStatus(ctx)
	case thread.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case thread.FieldIsCommentDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCommentDisabled(v)
		return nil
	case thread.FieldVisibility:
		v, ok := value.(thread.Visibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibility(v)
		return nil
	case thread.FieldStatus:
		v, ok := value.(thread.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case thread.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldContent:
		m.ResetContent()
		return nil
	case thread.FieldIsCommentDisabled:
		m.ResetIsCommentDisabled()
		return nil
	case thread.FieldVisibility:
		m.ResetVisibility()
		return nil
	case thread.FieldStatus:
		m.ResetStatus()
		return nil
	case thread.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent_thread != nil {
		edges = append(edges, thread.EdgeParentThread)
	}
	if m.child_threads != nil {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.images != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeParentThread:
		if id := m.parent_thread; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeChildThreads:
		ids := make([]ent.Value, 0, len(m.child_threads))
		for id := range m.child_threads {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchild_threads != nil {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.removedimages != nil {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeChildThreads:
		ids := make([]ent.Value, 0, len(m.removedchild_threads))
		for id := range m.removedchild_threads {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent_thread {
		edges = append(edges, thread.EdgeParentThread)
	}
	if m.clearedchild_threads {
		edges = append(edges, thread.EdgeChildThreads)
	}
	if m.clearedimages {
		edges = append(edges, thread.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeParentThread:
		return m.clearedparent_thread
	case thread.EdgeChildThreads:
		return m.clearedchild_threads
	case thread.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeParentThread:
		m.ClearParentThread()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeParentThread:
		m.ResetParentThread()
		return nil
	case thread.EdgeChildThreads:
		m.ResetChildThreads()
		return nil
	case thread.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAccountMutation represents an operation that mutates the UserAccount nodes in the graph.
type UserAccountMutation struct {
	config
	op                Op
	typ               string
	id                *int
	email             *string
	username          *string
	password          *string
	is_verified       *bool
	is_private        *bool
	is_email_verified *bool
	clearedFields     map[string]struct{}
	profile           *int
	clearedprofile    bool
	done              bool
	oldValue          func(context.Context) (*UserAccount, error)
	predicates        []predicate.UserAccount
}

var _ ent.Mutation = (*UserAccountMutation)(nil)

// useraccountOption allows management of the mutation configuration using functional options.
type useraccountOption func(*UserAccountMutation)

// newUserAccountMutation creates new mutation for the UserAccount entity.
func newUserAccountMutation(c config, op Op, opts ...useraccountOption) *UserAccountMutation {
	m := &UserAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAccountID sets the ID field of the mutation.
func withUserAccountID(id int) useraccountOption {
	return func(m *UserAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAccount
		)
		m.oldValue = func(ctx context.Context) (*UserAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAccount sets the old UserAccount of the mutation.
func withUserAccount(node *UserAccount) useraccountOption {
	return func(m *UserAccountMutation) {
		m.oldValue = func(context.Context) (*UserAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserAccountMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserAccountMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserAccountMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserAccountMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserAccountMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserAccountMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserAccountMutation) ResetPassword() {
	m.password = nil
}

// SetIsVerified sets the "is_verified" field.
func (m *UserAccountMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserAccountMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserAccountMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetIsPrivate sets the "is_private" field.
func (m *UserAccountMutation) SetIsPrivate(b bool) {
	m.is_private = &b
}

// IsPrivate returns the value of the "is_private" field in the mutation.
func (m *UserAccountMutation) IsPrivate() (r bool, exists bool) {
	v := m.is_private
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrivate returns the old "is_private" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrivate: %w", err)
	}
	return oldValue.IsPrivate, nil
}

// ResetIsPrivate resets all changes to the "is_private" field.
func (m *UserAccountMutation) ResetIsPrivate() {
	m.is_private = nil
}

// SetIsEmailVerified sets the "is_email_verified" field.
func (m *UserAccountMutation) SetIsEmailVerified(b bool) {
	m.is_email_verified = &b
}

// IsEmailVerified returns the value of the "is_email_verified" field in the mutation.
func (m *UserAccountMutation) IsEmailVerified() (r bool, exists bool) {
	v := m.is_email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEmailVerified returns the old "is_email_verified" field's value of the UserAccount entity.
// If the UserAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAccountMutation) OldIsEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEmailVerified: %w", err)
	}
	return oldValue.IsEmailVerified, nil
}

// ResetIsEmailVerified resets all changes to the "is_email_verified" field.
func (m *UserAccountMutation) ResetIsEmailVerified() {
	m.is_email_verified = nil
}

// SetProfileID sets the "profile" edge to the UserProfile entity by id.
func (m *UserAccountMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the UserProfile entity.
func (m *UserAccountMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the UserProfile entity was cleared.
func (m *UserAccountMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserAccountMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserAccountMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserAccountMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the UserAccountMutation builder.
func (m *UserAccountMutation) Where(ps ...predicate.UserAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAccount).
func (m *UserAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.email != nil {
		fields = append(fields, useraccount.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, useraccount.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, useraccount.FieldPassword)
	}
	if m.is_verified != nil {
		fields = append(fields, useraccount.FieldIsVerified)
	}
	if m.is_private != nil {
		fields = append(fields, useraccount.FieldIsPrivate)
	}
	if m.is_email_verified != nil {
		fields = append(fields, useraccount.FieldIsEmailVerified)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraccount.FieldEmail:
		return m.Email()
	case useraccount.FieldUsername:
		return m.Username()
	case useraccount.FieldPassword:
		return m.Password()
	case useraccount.FieldIsVerified:
		return m.IsVerified()
	case useraccount.FieldIsPrivate:
		return m.IsPrivate()
	case useraccount.FieldIsEmailVerified:
		return m.IsEmailVerified()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraccount.FieldEmail:
		return m.OldEmail(ctx)
	case useraccount.FieldUsername:
		return m.OldUsername(ctx)
	case useraccount.FieldPassword:
		return m.OldPassword(ctx)
	case useraccount.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case useraccount.FieldIsPrivate:
		return m.OldIsPrivate(ctx)
	case useraccount.FieldIsEmailVerified:
		return m.OldIsEmailVerified(ctx)
	}
	return nil, fmt.Errorf("unknown UserAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraccount.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case useraccount.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case useraccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case useraccount.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case useraccount.FieldIsPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrivate(v)
		return nil
	case useraccount.FieldIsEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEmailVerified(v)
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAccountMutation) ResetField(name string) error {
	switch name {
	case useraccount.FieldEmail:
		m.ResetEmail()
		return nil
	case useraccount.FieldUsername:
		m.ResetUsername()
		return nil
	case useraccount.FieldPassword:
		m.ResetPassword()
		return nil
	case useraccount.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case useraccount.FieldIsPrivate:
		m.ResetIsPrivate()
		return nil
	case useraccount.FieldIsEmailVerified:
		m.ResetIsEmailVerified()
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, useraccount.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useraccount.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, useraccount.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case useraccount.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAccountMutation) ClearEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown UserAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAccountMutation) ResetEdge(name string) error {
	switch name {
	case useraccount.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown UserAccount edge %s", name)
}

// UserProfileMutation represents an operation that mutates the UserProfile nodes in the graph.
type UserProfileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	display_name           *string
	bio                    *string
	clearedFields          map[string]struct{}
	account                *int
	clearedaccount         bool
	profile_picture        *int
	clearedprofile_picture bool
	banner                 *int
	clearedbanner          bool
	done                   bool
	oldValue               func(context.Context) (*UserProfile, error)
	predicates             []predicate.UserProfile
}

var _ ent.Mutation = (*UserProfileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserProfileMutation)

// newUserProfileMutation creates new mutation for the UserProfile entity.
func newUserProfileMutation(c config, op Op, opts ...userprofileOption) *UserProfileMutation {
	m := &UserProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProfileID sets the ID field of the mutation.
func withUserProfileID(id int) userprofileOption {
	return func(m *UserProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProfile
		)
		m.oldValue = func(ctx context.Context) (*UserProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProfile sets the old UserProfile of the mutation.
func withUserProfile(node *UserProfile) userprofileOption {
	return func(m *UserProfileMutation) {
		m.oldValue = func(context.Context) (*UserProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplayName sets the "display_name" field.
func (m *UserProfileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *UserProfileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *UserProfileMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetBio sets the "bio" field.
func (m *UserProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the UserProfile entity.
// If the UserProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ResetBio resets all changes to the "bio" field.
func (m *UserProfileMutation) ResetBio() {
	m.bio = nil
}

// SetAccountID sets the "account" edge to the UserAccount entity by id.
func (m *UserProfileMutation) SetAccountID(id int) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the UserAccount entity.
func (m *UserProfileMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the UserAccount entity was cleared.
func (m *UserProfileMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *UserProfileMutation) AccountID() (id int, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) AccountIDs() (ids []int) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserProfileMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetProfilePictureID sets the "profile_picture" edge to the Media entity by id.
func (m *UserProfileMutation) SetProfilePictureID(id int) {
	m.profile_picture = &id
}

// ClearProfilePicture clears the "profile_picture" edge to the Media entity.
func (m *UserProfileMutation) ClearProfilePicture() {
	m.clearedprofile_picture = true
}

// ProfilePictureCleared reports if the "profile_picture" edge to the Media entity was cleared.
func (m *UserProfileMutation) ProfilePictureCleared() bool {
	return m.clearedprofile_picture
}

// ProfilePictureID returns the "profile_picture" edge ID in the mutation.
func (m *UserProfileMutation) ProfilePictureID() (id int, exists bool) {
	if m.profile_picture != nil {
		return *m.profile_picture, true
	}
	return
}

// ProfilePictureIDs returns the "profile_picture" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfilePictureID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) ProfilePictureIDs() (ids []int) {
	if id := m.profile_picture; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfilePicture resets all changes to the "profile_picture" edge.
func (m *UserProfileMutation) ResetProfilePicture() {
	m.profile_picture = nil
	m.clearedprofile_picture = false
}

// SetBannerID sets the "banner" edge to the Media entity by id.
func (m *UserProfileMutation) SetBannerID(id int) {
	m.banner = &id
}

// ClearBanner clears the "banner" edge to the Media entity.
func (m *UserProfileMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Media entity was cleared.
func (m *UserProfileMutation) BannerCleared() bool {
	return m.clearedbanner
}

// BannerID returns the "banner" edge ID in the mutation.
func (m *UserProfileMutation) BannerID() (id int, exists bool) {
	if m.banner != nil {
		return *m.banner, true
	}
	return
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *UserProfileMutation) BannerIDs() (ids []int) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *UserProfileMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the UserProfileMutation builder.
func (m *UserProfileMutation) Where(ps ...predicate.UserProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProfile).
func (m *UserProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProfileMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.display_name != nil {
		fields = append(fields, userprofile.FieldDisplayName)
	}
	if m.bio != nil {
		fields = append(fields, userprofile.FieldBio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.DisplayName()
	case userprofile.FieldBio:
		return m.Bio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case userprofile.FieldBio:
		return m.OldBio(ctx)
	}
	return nil, fmt.Errorf("unknown UserProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case userprofile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProfileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case userprofile.FieldBio:
		m.ResetBio()
		return nil
	}
	return fmt.Errorf("unknown UserProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.account != nil {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.profile_picture != nil {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.banner != nil {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userprofile.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeProfilePicture:
		if id := m.profile_picture; id != nil {
			return []ent.Value{*id}
		}
	case userprofile.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedaccount {
		edges = append(edges, userprofile.EdgeAccount)
	}
	if m.clearedprofile_picture {
		edges = append(edges, userprofile.EdgeProfilePicture)
	}
	if m.clearedbanner {
		edges = append(edges, userprofile.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case userprofile.EdgeAccount:
		return m.clearedaccount
	case userprofile.EdgeProfilePicture:
		return m.clearedprofile_picture
	case userprofile.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProfileMutation) ClearEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ClearAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ClearProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProfileMutation) ResetEdge(name string) error {
	switch name {
	case userprofile.EdgeAccount:
		m.ResetAccount()
		return nil
	case userprofile.EdgeProfilePicture:
		m.ResetProfilePicture()
		return nil
	case userprofile.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown UserProfile edge %s", name)
}
